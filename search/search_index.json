{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"cladecombiner","text":"<p>This package provides functionality for working with taxa, with a focus on phylogenetic aggregation to higher-order taxa.</p> <p>While the functionality is intended to be general, current out-of-the-box support is limited to Pango lineages and Nextstrain clades for SARS-CoV-2.</p>"},{"location":"#taxon-clade-or-lineage","title":"Taxon, clade, or lineage?","text":"<p>For the purposes of cladecombiner and its documentation, a taxon is a unit of taxonomy. Nextstrain clades and Pango lineages for SARS-CoV-2 are both examples of taxa. We reserve the terms \"clade\" and \"lineage\" (unless referring to Nextstrain clades or Pango lineages) for the usual sense of monophyletic groupings defined by an ancestor and all its descendants.</p> <p>As clades can contain clades and lineages can contain lineages, taxa can contain taxa. Cladecombiner assumes that there is some base level of taxonomy which can be represented as a phylogeny with every taxon at this level as a tip. Cladecombiner defaults to monophyletic groupings of these taxa where possible, but allows for non-monophyletic aggregated taxa.</p>"},{"location":"#ancestral-versus-tip-taxa","title":"Ancestral versus tip taxa","text":"<p>When tracking ongoing evolution, the naming of new monophyletic taxa creates potential ambiguity when using the name of the now non-monophyletic ancestor. For example, JN.1 can refer to the ancestral taxon, which has children such as KP.2. It can also refer to JN.1 the taxon we can observe in data (a sequence which belongs to JN.1 but not any more specifically named descendant).</p> <p>Cladecombiner distinguishes between these two senses in which a taxon name can be used by adding tips to the underlying taxonomy tree to represent the non-monophyletic remainder. Thus, if needed, the ancestral <code>Taxon(\"JN.1\", is_tip=False)</code> can have as a descendant tip <code>Taxon(\"JN.1\", is_tip=True)</code>.</p>"},{"location":"#usage","title":"Usage","text":"<p>If we have line list data like this:</p> Lineage Location Date BA.2 IA 2233-03-22 BA.2.86 IA 2233-03-22 JN.1.9.1 IA 2233-03-22 KP.1.1 IA 2233-03-22 FW.1.1.1 IA 2233-03-22 <p>cladecombiner is a tool that provides mappings so that we can make it look like this:</p> Lineage Location Date BA.2 IA 2233-03-22 BA.2 IA 2233-03-22 JN.1 IA 2233-03-22 JN.1 IA 2233-03-22 JN.1 IA 2233-03-22 <p>Note that cladecombiner does not manipulate data tables itself. Instead, it provides taxon to taxon mappings which are generally suitable for this purpose in the form of python dictionaries. Thus, cladecombiner strives to be useful anywhere lineages need to be aggregated.</p> <p>At the moment, cladecombiner only supports aggregation when the final desired set of lineages is known. That is, it cannot currently choose what to aggregate to on its own. For more on doing this, see the documentation on phylogenetic aggregation of Pango lineages.</p>"},{"location":"#taxonomy-and-nomenclature","title":"Taxonomy and nomenclature","text":"<p>In cladecombiner parlance, nomenclature refers to rules for naming taxa while taxonomy specifies how taxa are related. Thus, if we want to check that all of the taxa in our data are valid Pango lineages for SARS-CoV-2, we use a <code>Nomenclature</code> object, while if we want to know whether JN.1 is ancestral to KP.2, we need to use a <code>TaxonomyScheme</code> object. We make this split, despite the fact that Pango names encode evolutionary history, for clean code separation.</p>"},{"location":"#nomenclature","title":"Nomenclature","text":"<p>Working with <code>Nomenclature</code> objects, we can check lineage name validity, get longer form names, and such.</p> <pre><code>import cladecombiner\nfrom cladecombiner import pango_sc2_nomenclature as pn\n\npn.setup_alias_map()\n\nmy_lineages = [\"JN.1\", \"KP.2\"]\n\npn.validate(my_lineages)\n# returns None, indicating validity\n\npn.longer_name(\"EG.1\")\n# 'XBB.1.9.2.1'\n</code></pre> <p>Cladecombiner distinguishes the general Pango nomenclature from the specific instance of Pango nomenclature for SARS-CoV-2. Other instances for other outbreaks, have different special taxa, different numbers of sublevels, and alias maps stored in different locations. For example, MPXV. Instances of other Pango nomenclature schemes can be made from the <code>PangoNomenclature</code> class by specificying this (and some additional) information.</p>"},{"location":"#taxonomy","title":"Taxonomy","text":"<p>To ask questions about taxonomy, we need a <code>TaxonomyScheme</code>. We can obtain one for the taxa of interest by getting the taxonomy tree describing their relationships, and creating a <code>PhylogeneticTaxonomyScheme</code> from it.</p> <p>Note that where <code>Nomenclature</code>s work on <code>str</code>s, <code>TaxonomyScheme</code>s work on <code>Taxon</code> objects. Every <code>Taxon</code> must either be declared as a tip (something observable directly) or not. Failure to appropriately specify this can lead to answers which seem nonsensical but which are in fact pedantically correct. For more, see above.</p> <p>Note also that <code>PhylogeneticTaxonomyScheme</code>s only know about the taxa from which they were created and their ancestors. That is, cladecombiner does not create the tree of all Pango SARS-CoV-2 lineages at any point unless we explicitly feed in an exhaustive list of all known lineages.</p> <pre><code>tree = pn.taxonomy_tree(my_taxa)\ntaxonomy_scheme = cladecombiner.PhylogeneticTaxonomyScheme(tree)\n\ntaxonomy_scheme.contains(\n    cladecombiner.Taxon(\"JN.1\", is_tip=False),\n    cladecombiner.Taxon(\"KP.2\", is_tip=True)\n)\n# True, ancestral JN.1 contains KP.1\n\ntaxonomy_scheme.contains(\n    cladecombiner.Taxon(\"JN.1\", is_tip=True),\n    cladecombiner.Taxon(\"KP.2\", is_tip=True)\n)\n# False, not-more-specifically-named JN.1 does not contain KP.1\n\ntaxonomy_scheme.contains(\n    cladecombiner.Taxon(\"JN.1\", is_tip=False),\n    cladecombiner.Taxon(\"KP.1\", is_tip=True)\n)\n# False, because KP.1 is unknown to taxonomy_scheme\n</code></pre>"},{"location":"api/","title":"API reference","text":""},{"location":"api/#cladecombiner.taxon","title":"<code>cladecombiner.taxon</code>","text":""},{"location":"api/#cladecombiner.taxon.Taxon","title":"<code>Taxon</code>","text":"<p>Representation of taxonomic units.</p> Source code in <code>cladecombiner/taxon.py</code> <pre><code>class Taxon:\n    \"\"\"\n    Representation of taxonomic units.\n    \"\"\"\n\n    def __init__(self, name: str, is_tip: bool, data: Any = None):\n        if not isinstance(is_tip, bool):\n            raise TypeError()\n        self.name: str = name\n        self.tip: bool = is_tip\n        self.data: Any = data\n\n    def __eq__(self, other) -&gt; bool:\n        return self.name == other.name and self.tip == other.tip\n\n    def __hash__(self) -&gt; int:\n        return hash(str(self.name) + str(self.tip))\n\n    def __repr__(self) -&gt; str:\n        return f\"Taxon({self.name}, tip={str(self.tip)})\"\n</code></pre>"},{"location":"api/#cladecombiner.taxon_utils","title":"<code>cladecombiner.taxon_utils</code>","text":""},{"location":"api/#cladecombiner.taxon_utils.printable_taxon_list","title":"<code>printable_taxon_list(taxa, sep='\\n')</code>","text":"<p>Prettier printing of lists of taxa.</p> <p>Parameters:</p> <ul> <li> <code>taxa</code>               (<code>sequence[Taxon]</code>)           \u2013            <p>The Taxon objects to be printed.</p> </li> <li> <code>sep</code>               (<code>str</code>, default:                   <code>'\\n'</code> )           \u2013            <p>The separator for printing the list</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A string which may be fed to print().</p> </li> </ul> Source code in <code>cladecombiner/taxon_utils.py</code> <pre><code>def printable_taxon_list(taxa: Sequence[Taxon], sep: str = \"\\n\") -&gt; str:\n    \"\"\"\n    Prettier printing of lists of taxa.\n\n    Parameters\n    ---------\n    taxa : sequence[Taxon]\n        The Taxon objects to be printed.\n    sep : str\n        The separator for printing the list\n\n    Returns\n    -------\n    str\n        A string which may be fed to print().\n    \"\"\"\n    print_str = \"\"\n    for taxon in taxa:\n        print_str += str(taxon) + sep\n    return print_str\n</code></pre>"},{"location":"api/#cladecombiner.taxon_utils.read_taxa","title":"<code>read_taxa(fp, is_tip=True, nomenclature=None, taxonomy_scheme=None)</code>","text":"<p>Reads in taxa as a list of Taxon objects.</p> <p>Parameters:</p> <ul> <li> <code>fp</code>               (<code>str</code>)           \u2013            <p>The file path to be read from</p> </li> <li> <code>is_tip</code>               (<code>bool | Sequence[bool]</code>, default:                   <code>True</code> )           \u2013            <p>Either one bool specifying whether all these are tip taxa or not, or one bool per taxon in the file specifying for each.</p> </li> <li> <code>nomenclature</code>               (<code>Optional[Nomenclature]</code>, default:                   <code>None</code> )           \u2013            <p>If specified, taxon names are checked for validity according to this nomenclature scheme, and an error is raised if an invalid taxon is found.</p> </li> <li> <code>taxonomy_scheme</code>               (<code>Optional[TaxonomyScheme]</code>, default:                   <code>None</code> )           \u2013            <p>If specified, taxon names are checked for validity according to this taxonomy scheme, and an error is raised if an invalid taxon is found.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Sequence[Taxon]</code>           \u2013            <p>Container of the taxa as Taxon objects.</p> </li> </ul> Source code in <code>cladecombiner/taxon_utils.py</code> <pre><code>def read_taxa(\n    fp: str,\n    is_tip: bool | Sequence[bool] = True,\n    nomenclature: Optional[Nomenclature] = None,\n    taxonomy_scheme: Optional[TaxonomyScheme] = None,\n) -&gt; Sequence[Taxon]:\n    \"\"\"\n    Reads in taxa as a list of Taxon objects.\n\n    Parameters\n    ---------\n    fp : str\n        The file path to be read from\n    is_tip : bool | Sequence[bool]\n        Either one bool specifying whether all these are tip taxa or not,\n        or one bool per taxon in the file specifying for each.\n    nomenclature : Optional[Nomenclature]\n        If specified, taxon names are checked for validity according to this\n        nomenclature scheme, and an error is raised if an invalid taxon is\n        found.\n    taxonomy_scheme : Optional[TaxonomyScheme]\n        If specified, taxon names are checked for validity according to this\n        taxonomy scheme, and an error is raised if an invalid taxon is found.\n\n    Returns\n    -------\n    Sequence[Taxon]\n        Container of the taxa as Taxon objects.\n    \"\"\"\n    assert nomenclature is None or isinstance(nomenclature, Nomenclature)\n\n    assert taxonomy_scheme is None or isinstance(\n        taxonomy_scheme, TaxonomyScheme\n    )\n\n    ext = path.splitext(fp)[1]\n    taxa = []\n    if ext == \".txt\":\n        f = open(fp)\n        lines = f.readlines()\n        f.close()\n        taxa = []\n        if not isinstance(is_tip, Sequence):\n            is_tip = [is_tip for _ in range(len(lines))]\n\n        for i in range(len(lines)):\n            taxon = Taxon(lines[i][:-1], is_tip[i])\n            taxa.append(taxon)\n\n    if nomenclature:\n        nomenclature.validate([taxon.name for taxon in taxa])\n\n    if taxonomy_scheme:\n        taxonomy_scheme.validate([taxon for taxon in taxa])\n    return taxa\n</code></pre>"},{"location":"api/#cladecombiner.taxon_utils.sort_taxa","title":"<code>sort_taxa(taxa, taxonomy_scheme)</code>","text":"<p>Sorts taxa into a phylogenetic preorder according to a taxonomy scheme, such that if taxon X contains Y, Y comes before X.</p> <p>For example, the Pango lineages [KP.1, JN.1, BA.2, BA.3] will be sorted such that (1) KP.1 comes before both JN.1 and BA.2 and (2) JN.1 appears before BA.2. The ordering of these with respect to BA.3 is arbitrary, as BA.3 is sister to BA.2 and its descendants.</p> <p>Parameters:</p> <ul> <li> <code>taxa</code>               (<code>Iterable[Taxon]</code>)           \u2013            <p>The Taxon objects to be sorted.</p> </li> <li> <code>taxonomy_scheme</code>               (<code>TreelikeTaxonomyScheme</code>)           \u2013            <p>The taxonomy scheme by which to sort the taxa.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Taxon]</code>           \u2013            <p>The sorted taxa.</p> </li> </ul> Source code in <code>cladecombiner/taxon_utils.py</code> <pre><code>def sort_taxa(\n    taxa: Iterable[Taxon], taxonomy_scheme: TreelikeTaxonomyScheme\n) -&gt; list[Taxon]:\n    \"\"\"\n    Sorts taxa into a phylogenetic preorder according to a taxonomy scheme, such that if\n    taxon X contains Y, Y comes before X.\n\n    For example, the Pango lineages [KP.1, JN.1, BA.2, BA.3] will be sorted such that (1) KP.1\n    comes before both JN.1 and BA.2 and (2) JN.1 appears before BA.2. The ordering of these\n    with respect to BA.3 is arbitrary, as BA.3 is sister to BA.2 and its descendants.\n\n    Parameters\n    ---------\n    taxa : Iterable[Taxon]\n        The Taxon objects to be sorted.\n    taxonomy_scheme : TreelikeTaxonomyScheme\n        The taxonomy scheme by which to sort the taxa.\n\n    Returns\n    -------\n    list[Taxon]\n        The sorted taxa.\n    \"\"\"\n    taxonomy_scheme.validate(taxa)\n    return sorted(\n        taxa,\n        key=cmp_to_key(\n            lambda x, y: 1 if taxonomy_scheme.contains(x, y) else -1\n        ),\n    )\n</code></pre>"},{"location":"api/#cladecombiner.aggregator","title":"<code>cladecombiner.aggregator</code>","text":""},{"location":"api/#cladecombiner.aggregator.Aggregation","title":"<code>Aggregation</code>","text":"<p>               Bases: <code>dict[Taxon, Taxon]</code></p> <p>An object for aggregations, basically just a dictionary.</p> Source code in <code>cladecombiner/aggregator.py</code> <pre><code>class Aggregation(dict[Taxon, Taxon]):\n    \"\"\"\n    An object for aggregations, basically just a dictionary.\n    \"\"\"\n\n    def _validate(\n        self, input_taxa: Iterable[Taxon], taxon_map: dict[Taxon, Taxon]\n    ):\n        \"\"\"\n        Checks that all input taxa are in the mapping.\n        \"\"\"\n        if set(taxon_map.keys()) != set(input_taxa):\n            raise RuntimeError(\n                \"Mismatch between aggregated taxa and input taxa. Input taxa are: \"\n                + str(input_taxa)\n                + \" but aggregated taxa are \"\n                + str(taxon_map.keys())\n            )\n\n    def __init__(\n        self, input_taxa: Iterable[Taxon], taxon_map: dict[Taxon, Taxon]\n    ):\n        self._validate(input_taxa, taxon_map)\n        super().__init__(taxon_map)\n\n    def to_str(self):\n        \"\"\"\n        Get str : str map of taxa names\n        \"\"\"\n        return {k.name: v.name for k, v in self.items()}\n</code></pre>"},{"location":"api/#cladecombiner.aggregator.Aggregation.to_str","title":"<code>to_str()</code>","text":"<p>Get str : str map of taxa names</p> Source code in <code>cladecombiner/aggregator.py</code> <pre><code>def to_str(self):\n    \"\"\"\n    Get str : str map of taxa names\n    \"\"\"\n    return {k.name: v.name for k, v in self.items()}\n</code></pre>"},{"location":"api/#cladecombiner.aggregator.Aggregator","title":"<code>Aggregator</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Aggregators return Aggregations, maps of input_taxon : aggregated_taxon</p> Source code in <code>cladecombiner/aggregator.py</code> <pre><code>class Aggregator(ABC):\n    \"\"\"\n    Aggregators return Aggregations, maps of input_taxon : aggregated_taxon\n    \"\"\"\n\n    @abstractmethod\n    def aggregate(self, input_taxa: Iterable[Taxon]) -&gt; Aggregation:\n        raise NotImplementedError()\n</code></pre>"},{"location":"api/#cladecombiner.aggregator.ArbitraryAggregator","title":"<code>ArbitraryAggregator</code>","text":"<p>               Bases: <code>Aggregator</code></p> <p>Aggregation via a user-provided dictionary.</p> Source code in <code>cladecombiner/aggregator.py</code> <pre><code>class ArbitraryAggregator(Aggregator):\n    \"\"\"\n    Aggregation via a user-provided dictionary.\n    \"\"\"\n\n    def __init__(\n        self,\n        map: dict[Taxon, Taxon],\n    ):\n        \"\"\"\n        FixedAggregator constructor.\n\n        Parameters\n        ----------\n        map : dict[Taxon, Taxon]\n            Dictionary mapping the input taxa to their aggregated taxa.\n        \"\"\"\n        self.map = map\n\n    def aggregate(self, input_taxa: Iterable[Taxon]) -&gt; Aggregation:\n        return Aggregation(\n            input_taxa, {taxon: self.map[taxon] for taxon in input_taxa}\n        )\n</code></pre>"},{"location":"api/#cladecombiner.aggregator.ArbitraryAggregator.__init__","title":"<code>__init__(map)</code>","text":"<p>FixedAggregator constructor.</p> <p>Parameters:</p> <ul> <li> <code>map</code>               (<code>dict[Taxon, Taxon]</code>)           \u2013            <p>Dictionary mapping the input taxa to their aggregated taxa.</p> </li> </ul> Source code in <code>cladecombiner/aggregator.py</code> <pre><code>def __init__(\n    self,\n    map: dict[Taxon, Taxon],\n):\n    \"\"\"\n    FixedAggregator constructor.\n\n    Parameters\n    ----------\n    map : dict[Taxon, Taxon]\n        Dictionary mapping the input taxa to their aggregated taxa.\n    \"\"\"\n    self.map = map\n</code></pre>"},{"location":"api/#cladecombiner.aggregator.AsOfAggregator","title":"<code>AsOfAggregator</code>","text":"<p>               Bases: <code>Aggregator</code></p> Source code in <code>cladecombiner/aggregator.py</code> <pre><code>class AsOfAggregator(Aggregator):\n    def __init__(\n        self,\n        taxonomy_scheme: PhylogeneticTaxonomyScheme,\n        versioning_provider: HistoryAwareNomenclature,\n        as_of: datetime.date,\n    ):\n        self.as_of = as_of\n        self.taxonomy_scheme = taxonomy_scheme\n        self.versioner = versioning_provider.get_versioner(as_of)\n        self.targets = None\n        \"\"\"\n        AsOfAggregator constructor.\n\n        Note that when using an AsOfAggregator, the resulting aggregated taxa\n        will only be tips if the taxon is a tip now and was a tip then. That\n        is, if there is an ancestral/internal corresponding taxon available,\n        a current tip will be mapped to that taxon.\n\n        Parameters\n        ----------\n        taxonomy_scheme : PhylogeneticTaxonomyScheme\n            The tree which we use to do the mapping.\n\n        versioning_provider : HistoryAwareNomenclature\n            A Nomenclature with a .get_versioner(as_of) method that can be used\n            to determine whether a taxon was recognized as-of the `as_of` date.\n\n        as_of : datetime.date\n            The as-of date. The time in the past which defines the set of\n            recognized taxa into which we wish to aggregate the input taxa.\n        \"\"\"\n\n    @staticmethod\n    def _get_versioned_taxa(\n        node: dendropy.Node,\n        versioner: NomenclatureVersioner,\n        taxa: list[tuple[str, bool, bool]],\n    ):\n        \"\"\"\n        Recursively add (taxon name, is currently internal, was internal as-of,) tuple to our list\n        \"\"\"\n\n        children_as_of = [\n            child\n            for child in node.child_node_iter()\n            if child.label != node.label and versioner(child.label)\n        ]\n\n        was_internal = False\n        if len(children_as_of) &gt; 0:\n            for child in children_as_of:\n                AsOfAggregator._get_versioned_taxa(child, versioner, taxa)\n            was_internal = True\n\n        taxa.append(\n            (\n                node.label,\n                not node.is_leaf(),\n                was_internal,\n            )\n        )\n\n    @staticmethod\n    def get_versioned_taxa(\n        tree: dendropy.Tree, versioner: NomenclatureVersioner\n    ) -&gt; Iterable[tuple[str, bool, bool]]:\n        \"\"\"\n        Get a list of (taxon name, is internal, was internal,) tuples for all taxa in the\n        current tree which were recognized on the as-of date.\n\n        Parameters\n        ----------\n        tree : dendropy.Tree\n            The tree which we use to do the mapping. Should come from a\n            PhylogeneticTaxonomyScheme.\n\n        versioner : NomenclatureVersioner\n            Used to determine if a name was recognized on the as-of date.\n\n        Returns\n        ----------\n        Iterable[tuple[str, bool, bool]]\n            For each taxon that was recognized on the as-of date, its name,\n            whether it has an internal node in the tree now, and whether it had\n            an internal node in the tree then. Per cladecombiner style, a taxon\n            name can belong to both an ancestral taxon and a tip. For such taxa,\n            only the ancestor will be recorded in this list.\n        \"\"\"\n        taxa = []\n        root = tree.seed_node\n        assert root is not None\n        assert versioner(root.label)\n        AsOfAggregator._get_versioned_taxa(root, versioner, taxa)\n        assert (\n            len(taxa) &gt; 0\n        ), \"Found no ancestors of input taxa for given as-of date.\"\n        return taxa\n\n    def aggregate(self, input_taxa: Iterable[Taxon]) -&gt; Aggregation:\n        if self.targets is None:\n            self.targets = self.get_targets()\n        agg = BasicPhylogeneticAggregator(\n            self.targets,\n            self.taxonomy_scheme,\n            sort_clades=True,\n            off_target=\"self\",\n            warn=False,\n        ).aggregate(input_taxa)\n        assert all(self.versioner(taxon.name) for taxon in agg.values())\n        return agg\n\n    def get_targets(self) -&gt; Collection[Taxon]:\n        taxa_as_of = AsOfAggregator.get_versioned_taxa(\n            self.taxonomy_scheme.tree, self.versioner\n        )\n        return [\n            Taxon(name, not is_internal) for name, is_internal, _ in taxa_as_of\n        ]\n</code></pre>"},{"location":"api/#cladecombiner.aggregator.AsOfAggregator.targets","title":"<code>targets = None</code>  <code>instance-attribute</code>","text":"<p>AsOfAggregator constructor.</p> <p>Note that when using an AsOfAggregator, the resulting aggregated taxa will only be tips if the taxon is a tip now and was a tip then. That is, if there is an ancestral/internal corresponding taxon available, a current tip will be mapped to that taxon.</p> <p>Parameters:</p> <ul> <li> <code>taxonomy_scheme</code>               (<code>PhylogeneticTaxonomyScheme</code>)           \u2013            <p>The tree which we use to do the mapping.</p> </li> <li> <code>versioning_provider</code>               (<code>HistoryAwareNomenclature</code>)           \u2013            <p>A Nomenclature with a .get_versioner(as_of) method that can be used to determine whether a taxon was recognized as-of the <code>as_of</code> date.</p> </li> <li> <code>as_of</code>               (<code>date</code>)           \u2013            <p>The as-of date. The time in the past which defines the set of recognized taxa into which we wish to aggregate the input taxa.</p> </li> </ul>"},{"location":"api/#cladecombiner.aggregator.AsOfAggregator.get_versioned_taxa","title":"<code>get_versioned_taxa(tree, versioner)</code>  <code>staticmethod</code>","text":"<p>Get a list of (taxon name, is internal, was internal,) tuples for all taxa in the current tree which were recognized on the as-of date.</p> <p>Parameters:</p> <ul> <li> <code>tree</code>               (<code>Tree</code>)           \u2013            <p>The tree which we use to do the mapping. Should come from a PhylogeneticTaxonomyScheme.</p> </li> <li> <code>versioner</code>               (<code>NomenclatureVersioner</code>)           \u2013            <p>Used to determine if a name was recognized on the as-of date.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterable[tuple[str, bool, bool]]</code>           \u2013            <p>For each taxon that was recognized on the as-of date, its name, whether it has an internal node in the tree now, and whether it had an internal node in the tree then. Per cladecombiner style, a taxon name can belong to both an ancestral taxon and a tip. For such taxa, only the ancestor will be recorded in this list.</p> </li> </ul> Source code in <code>cladecombiner/aggregator.py</code> <pre><code>@staticmethod\ndef get_versioned_taxa(\n    tree: dendropy.Tree, versioner: NomenclatureVersioner\n) -&gt; Iterable[tuple[str, bool, bool]]:\n    \"\"\"\n    Get a list of (taxon name, is internal, was internal,) tuples for all taxa in the\n    current tree which were recognized on the as-of date.\n\n    Parameters\n    ----------\n    tree : dendropy.Tree\n        The tree which we use to do the mapping. Should come from a\n        PhylogeneticTaxonomyScheme.\n\n    versioner : NomenclatureVersioner\n        Used to determine if a name was recognized on the as-of date.\n\n    Returns\n    ----------\n    Iterable[tuple[str, bool, bool]]\n        For each taxon that was recognized on the as-of date, its name,\n        whether it has an internal node in the tree now, and whether it had\n        an internal node in the tree then. Per cladecombiner style, a taxon\n        name can belong to both an ancestral taxon and a tip. For such taxa,\n        only the ancestor will be recorded in this list.\n    \"\"\"\n    taxa = []\n    root = tree.seed_node\n    assert root is not None\n    assert versioner(root.label)\n    AsOfAggregator._get_versioned_taxa(root, versioner, taxa)\n    assert (\n        len(taxa) &gt; 0\n    ), \"Found no ancestors of input taxa for given as-of date.\"\n    return taxa\n</code></pre>"},{"location":"api/#cladecombiner.aggregator.BasicPhylogeneticAggregator","title":"<code>BasicPhylogeneticAggregator</code>","text":"<p>               Bases: <code>Aggregator</code></p> <p>An aggregator which maps a set of input taxa to a fixed set of aggregation targets using a tree.</p> Source code in <code>cladecombiner/aggregator.py</code> <pre><code>class BasicPhylogeneticAggregator(Aggregator):\n    \"\"\"\n    An aggregator which maps a set of input taxa to a fixed set of aggregation targets using a tree.\n    \"\"\"\n\n    def __init__(\n        self,\n        targets: Iterable[Taxon],\n        taxonomy_scheme: PhylogeneticTaxonomyScheme,\n        sort_clades: bool = True,\n        off_target: str = \"other\",\n        warn: bool = True,\n    ):\n        \"\"\"\n        BasicPhylogeneticAggregator constructor.\n\n        Parameters\n        ----------\n        targets : Iterable[Taxon]\n            The taxa into which we wish to aggregate the input taxa.\n\n        taxonomy_scheme : PhylogeneticTaxonomyScheme\n            The tree which we use to do the mapping.\n\n        sort_clades : bool\n            If False, mapping is done using the taxa as ordered in `targets`.\n            If True, `targets` are taxonomically sorted so that so that larger\n            `targets` do not override smaller ones. For example, if BA.2 and\n            BA.2.86 are both aggregation targets, sort_clades = True would handle\n            BA.2.86 first, such that JN.1 would map to BA.2.86, while BG.1 would\n            map to BA.2. If BA.2 is processed first, both will map to it.\n\n        off_target : str\n            Specifies what to do with taxa which do not belong to any target.\n            Options are \"other\" for aggregating all such taxa into Taxon(\"other\"),\n            and \"self\" for aggregating all such taxa into themselves.\n        \"\"\"\n        self.taxonomy_scheme = taxonomy_scheme\n        self.taxonomy_scheme.validate(targets)\n        self.targets = [taxon for taxon in targets]\n        off_target_options = [\"self\", \"other\"]\n        if off_target not in off_target_options:\n            raise RuntimeError(\n                f\"Unrecognized value for `off_target`, options are:{off_target}\"\n            )\n        self.off_target = off_target\n        self.warn = warn\n        if sort_clades:\n            self.targets = sort_taxa(self.targets, self.taxonomy_scheme)\n\n    def _check_missing(self, agg_map: dict[Taxon, Taxon]):\n        if self.warn:\n            used_targets = set(agg_map.values())\n            unused_targets = [\n                target for target in self.targets if target not in used_targets\n            ]\n            if len(unused_targets) &gt; 0:\n                warn(\n                    f\"The aggregation does not make use of the following input targets: {unused_targets}.\"\n                )\n\n    def aggregate(self, input_taxa: Iterable[Taxon]) -&gt; Aggregation:\n        self.taxonomy_scheme.validate(input_taxa)\n        agg_map: dict[Taxon, Taxon] = {}\n        stack = set(input_taxa)\n        for target in self.targets:\n            children = self.taxonomy_scheme.descendants(target, True)\n            sub_map = {taxon: target for taxon in stack if taxon in children}\n            agg_map = agg_map | sub_map\n            stack.difference_update(set(agg_map.keys()))\n\n        if len(stack) &gt; 0:\n            if self.off_target == \"other\":\n                cleanup = HomogenousAggregator(\n                    Taxon(\"other\", False)\n                ).aggregate(stack)\n            else:\n                cleanup = SelfAggregator().aggregate(stack)\n            agg_map = agg_map | cleanup\n\n        self._check_missing(agg_map)\n\n        return Aggregation(input_taxa, agg_map)\n</code></pre>"},{"location":"api/#cladecombiner.aggregator.BasicPhylogeneticAggregator.__init__","title":"<code>__init__(targets, taxonomy_scheme, sort_clades=True, off_target='other', warn=True)</code>","text":"<p>BasicPhylogeneticAggregator constructor.</p> <p>Parameters:</p> <ul> <li> <code>targets</code>               (<code>Iterable[Taxon]</code>)           \u2013            <p>The taxa into which we wish to aggregate the input taxa.</p> </li> <li> <code>taxonomy_scheme</code>               (<code>PhylogeneticTaxonomyScheme</code>)           \u2013            <p>The tree which we use to do the mapping.</p> </li> <li> <code>sort_clades</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If False, mapping is done using the taxa as ordered in <code>targets</code>. If True, <code>targets</code> are taxonomically sorted so that so that larger <code>targets</code> do not override smaller ones. For example, if BA.2 and BA.2.86 are both aggregation targets, sort_clades = True would handle BA.2.86 first, such that JN.1 would map to BA.2.86, while BG.1 would map to BA.2. If BA.2 is processed first, both will map to it.</p> </li> <li> <code>off_target</code>               (<code>str</code>, default:                   <code>'other'</code> )           \u2013            <p>Specifies what to do with taxa which do not belong to any target. Options are \"other\" for aggregating all such taxa into Taxon(\"other\"), and \"self\" for aggregating all such taxa into themselves.</p> </li> </ul> Source code in <code>cladecombiner/aggregator.py</code> <pre><code>def __init__(\n    self,\n    targets: Iterable[Taxon],\n    taxonomy_scheme: PhylogeneticTaxonomyScheme,\n    sort_clades: bool = True,\n    off_target: str = \"other\",\n    warn: bool = True,\n):\n    \"\"\"\n    BasicPhylogeneticAggregator constructor.\n\n    Parameters\n    ----------\n    targets : Iterable[Taxon]\n        The taxa into which we wish to aggregate the input taxa.\n\n    taxonomy_scheme : PhylogeneticTaxonomyScheme\n        The tree which we use to do the mapping.\n\n    sort_clades : bool\n        If False, mapping is done using the taxa as ordered in `targets`.\n        If True, `targets` are taxonomically sorted so that so that larger\n        `targets` do not override smaller ones. For example, if BA.2 and\n        BA.2.86 are both aggregation targets, sort_clades = True would handle\n        BA.2.86 first, such that JN.1 would map to BA.2.86, while BG.1 would\n        map to BA.2. If BA.2 is processed first, both will map to it.\n\n    off_target : str\n        Specifies what to do with taxa which do not belong to any target.\n        Options are \"other\" for aggregating all such taxa into Taxon(\"other\"),\n        and \"self\" for aggregating all such taxa into themselves.\n    \"\"\"\n    self.taxonomy_scheme = taxonomy_scheme\n    self.taxonomy_scheme.validate(targets)\n    self.targets = [taxon for taxon in targets]\n    off_target_options = [\"self\", \"other\"]\n    if off_target not in off_target_options:\n        raise RuntimeError(\n            f\"Unrecognized value for `off_target`, options are:{off_target}\"\n        )\n    self.off_target = off_target\n    self.warn = warn\n    if sort_clades:\n        self.targets = sort_taxa(self.targets, self.taxonomy_scheme)\n</code></pre>"},{"location":"api/#cladecombiner.aggregator.HomogenousAggregator","title":"<code>HomogenousAggregator</code>","text":"<p>               Bases: <code>Aggregator</code></p> <p>Aggregation of every taxon to some catch-all taxon.</p> Source code in <code>cladecombiner/aggregator.py</code> <pre><code>class HomogenousAggregator(Aggregator):\n    \"\"\"\n    Aggregation of every taxon to some catch-all taxon.\n    \"\"\"\n\n    def __init__(self, taxon: Taxon):\n        self.agg_taxon = taxon\n\n    def aggregate(self, input_taxa: Iterable[Taxon]) -&gt; Aggregation:\n        return Aggregation(\n            input_taxa, {taxon: self.agg_taxon for taxon in input_taxa}\n        )\n</code></pre>"},{"location":"api/#cladecombiner.aggregator.SelfAggregator","title":"<code>SelfAggregator</code>","text":"<p>               Bases: <code>Aggregator</code></p> <p>Aggregation of every taxon to itself</p> Source code in <code>cladecombiner/aggregator.py</code> <pre><code>class SelfAggregator(Aggregator):\n    \"\"\"\n    Aggregation of every taxon to itself\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def aggregate(self, input_taxa: Iterable[Taxon]) -&gt; Aggregation:\n        return Aggregation(input_taxa, {taxon: taxon for taxon in input_taxa})\n</code></pre>"},{"location":"api/#cladecombiner.aggregator.SerialAggregator","title":"<code>SerialAggregator</code>","text":"<p>               Bases: <code>Aggregator</code></p> <p>A number of aggregators chained in serial.</p> Source code in <code>cladecombiner/aggregator.py</code> <pre><code>class SerialAggregator(Aggregator):\n    \"\"\"\n    A number of aggregators chained in serial.\n    \"\"\"\n\n    def __init__(self, aggregators: Iterable[Aggregator]):\n        self.aggregators = aggregators\n\n    def aggregate(self, input_taxa: Iterable[Taxon]) -&gt; Aggregation:\n        taxa = list(input_taxa)\n        comp_agg = SelfAggregator().aggregate(input_taxa)\n\n        for aggregator in self.aggregators:\n            agg = aggregator.aggregate(taxa)\n            taxa = set(agg.values())\n            comp_agg = {taxon: agg[comp_agg[taxon]] for taxon in input_taxa}\n\n        return Aggregation(input_taxa, comp_agg)\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature","title":"<code>cladecombiner.nomenclature</code>","text":""},{"location":"api/#cladecombiner.nomenclature.nextstrain_sc2_nomenclature","title":"<code>nextstrain_sc2_nomenclature = NextstrainLikeNomenclature(repo='nextstrain/ncov', as_of=(datetime.datetime.now()), master_list='defaults/clades.tsv', master_list_parser=_nextstrain_sc2_extractor, treefile='defaults/clade_hierarchy.tsv', treefile_parser=(lambda edge_table: tree_from_edge_table_string(edge_table=edge_table, delimiter='\\t', parent_col='parent', child_col='clade')), root='19A', name='NextstrainClades(SARS-CoV-2)', ambiguous_fun=(lambda _: False), hybrid_fun=(lambda _: False))</code>  <code>module-attribute</code>","text":"<p>Nextstrain clade nomenclature for SARS-CoV-2.</p> <p>A pre-baked ArbitraryGithubNomenclature, does not include subclades.</p> <p>See: https://docs.nextstrain.org/projects/ncov/en/latest/reference/naming_clades.html</p>"},{"location":"api/#cladecombiner.nomenclature.pango_sc2_nomenclature","title":"<code>pango_sc2_nomenclature = PangoNomenclature(alias_map_hybrid=[list], max_sublevels=3, special=['A', 'B'], system='SARS-CoV-2', repo='cov-lineages/pango-designation', repo_alias_path='pango_designation/alias_key.json', repo_versioning_path='lineage_notes.txt', versioning_extractor=_pango_sc2_extractor)</code>  <code>module-attribute</code>","text":"<p>Pango nomenclature for SARS-CoV-2.</p> <p>A PangoNomenclature with a specific .name() method, a known url for the alias map, maximally 3 sublevels, and the special root descendants A and B.</p> <p>See: https://doi.org/10.1038/s41564-020-0770-5</p>"},{"location":"api/#cladecombiner.nomenclature.AlgorithmicNomenclature","title":"<code>AlgorithmicNomenclature</code>","text":"<p>               Bases: <code>Nomenclature</code></p> <p>Abstract class Nomenclature schemes which encode a taxon's history in its name in some form.</p> <p>The primary exemplar is the Pango nomenclature, which descends from this class via the more-general PangoLikeNomenclature.</p> <p>This class assumes that the history of a set of taxa can be decoded (in some way), the result being for each taxon a Sequence of taxa linking the root to it. A method is provided for constructing from these histories a tree suitable for use in PhylogeneticTaxonomyScheme.</p> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>class AlgorithmicNomenclature(Nomenclature):\n    \"\"\"\n    Abstract class Nomenclature schemes which encode a taxon's history in its\n    name in some form.\n\n    The primary exemplar is the Pango nomenclature, which descends from this\n    class via the more-general PangoLikeNomenclature.\n\n    This class assumes that the history of a set of taxa can be decoded (in\n    some way), the result being for each taxon a Sequence of taxa linking\n    the root to it. A method is provided for constructing from these histories\n    a tree suitable for use in PhylogeneticTaxonomyScheme.\n    \"\"\"\n\n    @abstractmethod\n    def full_histories(\n        self, taxa: Sequence[str], stop_at_hybrid: bool = False\n    ) -&gt; Sequence[Sequence[str]]:\n        \"\"\"\n        For each taxon, get the sequence of names of ancestors from the root\n        to it.\n\n        Parameters\n        ----------\n        taxa : Sequence[str]\n            Each string is the name of one taxon for which we want the full\n            history.\n        stop_at_hybrid : boolean\n            If True, the history for a taxon starts at the most recent\n            hybridization event in its ancestry. If False, we extract a linear\n            history by taking the ancestry through the first indicated parent\n            every time.\n\n        Returns\n        -------\n        Sequence[Sequence[str]]\n            For each input taxon, the history from the root to the taxon as a\n            Sequence of names of taxa.\n        \"\"\"\n        raise NotImplementedError()\n\n    def subtree_from_histories(\n        self, node: dendropy.Node, lvl: int, histories: Sequence[Sequence[str]]\n    ) -&gt; None:\n        \"\"\"\n        Recursive building of taxonomic tree from taxon-specific histories.\n\n        Parameters\n        ----------\n        node : dendropy.Node\n            Node defining the subtree to operate on.\n        lvl : int\n            How many levels deep from the root are we?\n        histories: Sequence[Sequence[str]]\n            The histories of all taxa in this subtree for which we are\n            attempting to construct the subtree.\n\n        Returns\n        -------\n        None\n            Modifies tree in-place recursively.\n        \"\"\"\n        next_step = set([history[lvl] for history in histories])\n        if len(next_step) == 1:\n            child = dendropy.Node(label=next_step.pop())\n            node.add_child(child)\n            next_histories = [\n                history for history in histories if len(history) &gt; lvl + 1\n            ]\n            if next_histories:\n                self.subtree_from_histories(child, lvl + 1, next_histories)\n        elif len(next_step) &gt; 1:\n            for step in next_step:\n                child = dendropy.Node(label=step)\n                node.add_child(child)\n                next_histories = [\n                    history\n                    for history in histories\n                    if len(history) &gt; lvl + 1 and history[lvl] == step\n                ]\n                if next_histories:\n                    self.subtree_from_histories(child, lvl + 1, next_histories)\n\n    def taxonomy_tree(\n        self,\n        taxa: Sequence[Taxon],\n        insert_tips: bool,\n        name_cleanup_fun: Optional[Callable[[str], str]] = None,\n        warn: bool = True,\n    ) -&gt; dendropy.Tree:\n        unique_names = list(set([taxon.name for taxon in taxa if taxon.tip]))\n        if warn and (len(unique_names) &lt; len(taxa)):\n            warnings.warn(\n                \"Removed non-unique and/or non-tip taxa to build tree.\"\n            )\n\n        histories = self.full_histories(unique_names)\n\n        all_names: set[str] = set()\n        for history in histories:\n            for taxon in history:\n                all_names.add(taxon)\n\n        namespace = dendropy.TaxonNamespace(list(all_names))\n        phy = dendropy.Tree(taxon_namespace=namespace)\n        node = phy.seed_node\n        if not isinstance(node, dendropy.Node):\n            # Should never hit, required for type checking\n            raise RuntimeError(\n                \"Cannot start tree because seed_node is not a dendropy.Node\"\n            )\n\n        # Support for forests, where we break trees at recombination, could be added\n        first_step = set([history[0] for history in histories])\n        if len(first_step) != 1:\n            raise RuntimeError(\n                \"Cannot start tree, not all histories have same root\"\n            )\n        node.label = first_step.pop()\n\n        self.subtree_from_histories(node, 1, histories)\n\n        if name_cleanup_fun is not None:\n            for node in phy.preorder_node_iter():\n                node.label = name_cleanup_fun(node.label)\n\n        if insert_tips:\n            phy = add_paraphyletic_tips(phy, unique_names)\n\n        tip_names = [node.label for node in phy.leaf_node_iter()]\n        int_names = [node.label for node in phy.preorder_internal_node_iter()]\n\n        if len(set(tip_names)) != len(tip_names):\n            tab = Counter(tip_names)\n            mults = \", \".join(\n                [\n                    str(k) + \" (x\" + str(v) + \")\"\n                    for k, v in tab.items()\n                    if v &gt; 1\n                ]\n            )\n            raise RuntimeError(\n                \"Malformed tree has multiples of tip taxa: \" + mults\n            )\n\n        if len(set(int_names)) != len(int_names):\n            tab = Counter(int_names)\n            mults = \", \".join(\n                [\n                    str(k) + \" (x\" + str(v) + \")\"\n                    for k, v in tab.items()\n                    if v &gt; 1\n                ]\n            )\n            raise RuntimeError(\n                \"Malformed tree has multiples of internal taxa: \" + mults\n            )\n\n        return phy\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.AlgorithmicNomenclature.full_histories","title":"<code>full_histories(taxa, stop_at_hybrid=False)</code>  <code>abstractmethod</code>","text":"<p>For each taxon, get the sequence of names of ancestors from the root to it.</p> <p>Parameters:</p> <ul> <li> <code>taxa</code>               (<code>Sequence[str]</code>)           \u2013            <p>Each string is the name of one taxon for which we want the full history.</p> </li> <li> <code>stop_at_hybrid</code>               (<code>boolean</code>, default:                   <code>False</code> )           \u2013            <p>If True, the history for a taxon starts at the most recent hybridization event in its ancestry. If False, we extract a linear history by taking the ancestry through the first indicated parent every time.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Sequence[Sequence[str]]</code>           \u2013            <p>For each input taxon, the history from the root to the taxon as a Sequence of names of taxa.</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>@abstractmethod\ndef full_histories(\n    self, taxa: Sequence[str], stop_at_hybrid: bool = False\n) -&gt; Sequence[Sequence[str]]:\n    \"\"\"\n    For each taxon, get the sequence of names of ancestors from the root\n    to it.\n\n    Parameters\n    ----------\n    taxa : Sequence[str]\n        Each string is the name of one taxon for which we want the full\n        history.\n    stop_at_hybrid : boolean\n        If True, the history for a taxon starts at the most recent\n        hybridization event in its ancestry. If False, we extract a linear\n        history by taking the ancestry through the first indicated parent\n        every time.\n\n    Returns\n    -------\n    Sequence[Sequence[str]]\n        For each input taxon, the history from the root to the taxon as a\n        Sequence of names of taxa.\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.AlgorithmicNomenclature.subtree_from_histories","title":"<code>subtree_from_histories(node, lvl, histories)</code>","text":"<p>Recursive building of taxonomic tree from taxon-specific histories.</p> <p>Parameters:</p> <ul> <li> <code>node</code>               (<code>Node</code>)           \u2013            <p>Node defining the subtree to operate on.</p> </li> <li> <code>lvl</code>               (<code>int</code>)           \u2013            <p>How many levels deep from the root are we?</p> </li> <li> <code>histories</code>               (<code>Sequence[Sequence[str]]</code>)           \u2013            <p>The histories of all taxa in this subtree for which we are attempting to construct the subtree.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>Modifies tree in-place recursively.</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def subtree_from_histories(\n    self, node: dendropy.Node, lvl: int, histories: Sequence[Sequence[str]]\n) -&gt; None:\n    \"\"\"\n    Recursive building of taxonomic tree from taxon-specific histories.\n\n    Parameters\n    ----------\n    node : dendropy.Node\n        Node defining the subtree to operate on.\n    lvl : int\n        How many levels deep from the root are we?\n    histories: Sequence[Sequence[str]]\n        The histories of all taxa in this subtree for which we are\n        attempting to construct the subtree.\n\n    Returns\n    -------\n    None\n        Modifies tree in-place recursively.\n    \"\"\"\n    next_step = set([history[lvl] for history in histories])\n    if len(next_step) == 1:\n        child = dendropy.Node(label=next_step.pop())\n        node.add_child(child)\n        next_histories = [\n            history for history in histories if len(history) &gt; lvl + 1\n        ]\n        if next_histories:\n            self.subtree_from_histories(child, lvl + 1, next_histories)\n    elif len(next_step) &gt; 1:\n        for step in next_step:\n            child = dendropy.Node(label=step)\n            node.add_child(child)\n            next_histories = [\n                history\n                for history in histories\n                if len(history) &gt; lvl + 1 and history[lvl] == step\n            ]\n            if next_histories:\n                self.subtree_from_histories(child, lvl + 1, next_histories)\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.ArbitraryNomenclature","title":"<code>ArbitraryNomenclature</code>","text":"<p>               Bases: <code>Nomenclature</code></p> <p>A class for nomenclature where a taxon's history is divorced from its name.</p> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>class ArbitraryNomenclature(Nomenclature):\n    \"\"\"\n    A class for nomenclature where a taxon's history is divorced from its name.\n    \"\"\"\n\n    def __init__(\n        self,\n        known_taxa: Container[str],\n        root: str,\n        name: str,\n        ambiguous_fun: Callable,\n        hybrid_fun: Callable,\n    ):\n        \"\"\"\n        Initialization of ArbitraryNomenclature objects.\n\n        Parameters\n        ----------\n        known_taxa : Container[str]\n            The names of all taxa recognized by this nomenclature system.\n        name : str\n            The name of this nomenclature system.\n        ambiguous_fun : Callable\n            A Callable(name: str) -&gt; bool that takes in a name and returns whether\n            or not it is ambiguous.\n        hybrid_fun : Callable\n            A Callable(name: str) -&gt; bool that takes in a name and returns whether\n            or not it is a hybrid.\n        root: str\n            The name of the taxon that includes all others.\n        \"\"\"\n        self.taxa = known_taxa\n        self.root = root\n        self._name = name\n        self.ambiguous_fun = ambiguous_fun\n        self.hybrid_fun = hybrid_fun\n\n        if not isinstance(ambiguous_fun, Callable):\n            raise TypeError(\"Argument `ambiguous_fun` must be a callable.\")\n\n        if not isinstance(hybrid_fun, Callable):\n            raise TypeError(\"Argument `hybrid_fun` must be a callable.\")\n\n    def is_ambiguous(self, name: str) -&gt; bool:\n        return self.ambiguous_fun(name)\n\n    def is_hybrid(self, name: str) -&gt; bool:\n        return self.hybrid_fun(name)\n\n    def is_root(self, name: str) -&gt; bool:\n        return name == self.root\n\n    def is_valid_name(self, name: str) -&gt; bool:\n        return name in self.taxa\n\n    def name(self) -&gt; str:\n        return self._name\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.ArbitraryNomenclature.__init__","title":"<code>__init__(known_taxa, root, name, ambiguous_fun, hybrid_fun)</code>","text":"<p>Initialization of ArbitraryNomenclature objects.</p> <p>Parameters:</p> <ul> <li> <code>known_taxa</code>               (<code>Container[str]</code>)           \u2013            <p>The names of all taxa recognized by this nomenclature system.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of this nomenclature system.</p> </li> <li> <code>ambiguous_fun</code>               (<code>Callable</code>)           \u2013            <p>A Callable(name: str) -&gt; bool that takes in a name and returns whether or not it is ambiguous.</p> </li> <li> <code>hybrid_fun</code>               (<code>Callable</code>)           \u2013            <p>A Callable(name: str) -&gt; bool that takes in a name and returns whether or not it is a hybrid.</p> </li> <li> <code>root</code>               (<code>str</code>)           \u2013            <p>The name of the taxon that includes all others.</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def __init__(\n    self,\n    known_taxa: Container[str],\n    root: str,\n    name: str,\n    ambiguous_fun: Callable,\n    hybrid_fun: Callable,\n):\n    \"\"\"\n    Initialization of ArbitraryNomenclature objects.\n\n    Parameters\n    ----------\n    known_taxa : Container[str]\n        The names of all taxa recognized by this nomenclature system.\n    name : str\n        The name of this nomenclature system.\n    ambiguous_fun : Callable\n        A Callable(name: str) -&gt; bool that takes in a name and returns whether\n        or not it is ambiguous.\n    hybrid_fun : Callable\n        A Callable(name: str) -&gt; bool that takes in a name and returns whether\n        or not it is a hybrid.\n    root: str\n        The name of the taxon that includes all others.\n    \"\"\"\n    self.taxa = known_taxa\n    self.root = root\n    self._name = name\n    self.ambiguous_fun = ambiguous_fun\n    self.hybrid_fun = hybrid_fun\n\n    if not isinstance(ambiguous_fun, Callable):\n        raise TypeError(\"Argument `ambiguous_fun` must be a callable.\")\n\n    if not isinstance(hybrid_fun, Callable):\n        raise TypeError(\"Argument `hybrid_fun` must be a callable.\")\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.HistoryAwareNomenclature","title":"<code>HistoryAwareNomenclature</code>","text":"<p>               Bases: <code>Nomenclature</code></p> <p>A non-abstract HistoryAwareNomenclature should know how to get information about prior versions.</p> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>class HistoryAwareNomenclature(Nomenclature):\n    \"\"\"\n    A non-abstract HistoryAwareNomenclature should know how to get information about prior versions.\n    \"\"\"\n\n    @abstractmethod\n    def get_versioner(self, as_of: datetime.date) -&gt; NomenclatureVersioner:\n        raise NotImplementedError()\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.NextstrainLikeNomenclature","title":"<code>NextstrainLikeNomenclature</code>","text":"<p>               Bases: <code>ArbitraryNomenclature</code>, <code>HistoryAwareNomenclature</code>, <code>TreeProvider</code></p> <p>A class for arbitrary nomenclatures like Nextstrain, which are in GitHub repositories that also contain taxonomic information.</p> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>class NextstrainLikeNomenclature(\n    ArbitraryNomenclature, HistoryAwareNomenclature, TreeProvider\n):\n    \"\"\"\n    A class for arbitrary nomenclatures like Nextstrain, which are in GitHub\n    repositories that also contain taxonomic information.\n    \"\"\"\n\n    def __init__(\n        self,\n        repo: str,\n        as_of: datetime.date,\n        master_list: str,\n        master_list_parser: Callable[[str], Collection[str]],\n        treefile: str,\n        treefile_parser: Callable[[str], dendropy.Tree],\n        root: str,\n        name: str,\n        ambiguous_fun: Callable,\n        hybrid_fun: Callable,\n    ):\n        \"\"\"\n        NextstrainLikeNomenclature initialization.\n\n        Parameters\n        ----------\n        repo : str\n            The username/repo combination for the GitHub repository storing this nomenclature.\n        as_of: datetime.date\n            Sets the as-of date in fulfillment of VersionedNomenclature.\n        master_list : str\n            The filepath, relative to `repo` where the master list of known names is available.\n        master_list_parser: Callable[[str], Collection[str]]\n            Used to extract the known taxa from the master list file.\n        treefile : str\n            The filepath, relative to `repo` where the tree of taxa is stored.\n        treefile_parser: Callable[[str], dendropy.Tree]\n            Used to extract the tree of known taxa from the treefile.\n        name : str\n            The name of this nomenclature system.\n        ambiguous_fun : Callable\n            A Callable(name: str) -&gt; bool that takes in a name and returns whether\n            or not it is ambiguous.\n        hybrid_fun : Callable\n            A Callable(name: str) -&gt; bool that takes in a name and returns whether\n            or not it is a hybrid.\n        root: str\n            The name of the taxon that includes all others.\n        \"\"\"\n        self.repo = repo\n        self._as_of = as_of\n        self.master_list = master_list\n        self.master_list_parser = master_list_parser\n        self.treefile = treefile\n        self.treefile_parser = treefile_parser\n        self.obtained_taxa = False\n        self.master_tree = None\n\n        super().__init__(\n            known_taxa=[],\n            root=root,\n            name=name,\n            ambiguous_fun=ambiguous_fun,\n            hybrid_fun=hybrid_fun,\n        )\n\n    ##############################\n    # Superclass implementations #\n    ##############################\n\n    @ensure_tree_known\n    def taxonomy_tree(\n        self,\n        taxa: Sequence[Taxon],\n        insert_tips: bool = True,\n        name_cleanup_fun: Optional[Callable[[str], str]] = None,\n        warn: bool = True,\n    ) -&gt; dendropy.Tree:\n        assert isinstance(self.master_tree, dendropy.Tree)\n        phy: dendropy.Tree = self.master_tree.clone(2)\n        assert isinstance(phy, dendropy.Tree)\n\n        unique_names = list(set([taxon.name for taxon in taxa if taxon.tip]))\n        if warn and (len(unique_names) &lt; len(taxa)):\n            warnings.warn(\n                \"Removed non-unique and/or non-tip taxa to build tree.\"\n            )\n\n        if name_cleanup_fun is not None:\n            for node in phy.preorder_node_iter():\n                node.label = name_cleanup_fun(node.label)\n\n        if insert_tips:\n            phy = add_paraphyletic_tips(phy, unique_names)\n        else:\n            raise NotImplementedError(\"`insert_tips` must be true\")\n\n        return prune_nonancestral(phy, unique_names)\n\n    def get_versioner(self, as_of: datetime.date) -&gt; NomenclatureVersioner:\n        self_as_of = self.as_of()\n        if as_of &gt; datetime.date(\n            self_as_of.year, self_as_of.month, self_as_of.day\n        ):\n            raise ValueError(\n                \"Cannot get versioner for more recent iterations of nomenclature.\"\n            )\n        return NomenclatureVersioner.from_gh_file(\n            self.repo, self.master_list, as_of, self.master_list_parser\n        )\n\n    ########################\n    # Superclass overrides #\n    ########################\n\n    @ensure_taxa_known\n    def is_ambiguous(self, name: str) -&gt; bool:\n        return super().is_ambiguous(name)\n\n    @ensure_taxa_known\n    def is_hybrid(self, name: str) -&gt; bool:\n        return super().is_hybrid(name)\n\n    @ensure_taxa_known\n    def is_root(self, name: str) -&gt; bool:\n        return super().is_root(name)\n\n    @ensure_taxa_known\n    def is_valid_name(self, name: str) -&gt; bool:\n        return super().is_valid_name(name)\n\n    #################\n    # Class methods #\n    #################\n    def as_of(self) -&gt; datetime.date:\n        return self._as_of\n\n    def populate_taxa(self):\n        \"\"\"\n        Get taxa from GitHub repo. Separated from __init__ so as not to call on startup.\n        \"\"\"\n        self.taxa = self.master_list_parser(\n            get_gh_file_contents_as_of(\n                self.repo, self.master_list, self.as_of()\n            )\n        )\n\n    def populate_tree(self):\n        \"\"\"\n        Get tree from GitHub repo. Separated from __init__ so as not to call on startup.\n        \"\"\"\n        self.master_tree = self.treefile_parser(\n            get_gh_file_contents_as_of(self.repo, self.treefile, self.as_of())\n        )\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.NextstrainLikeNomenclature.__init__","title":"<code>__init__(repo, as_of, master_list, master_list_parser, treefile, treefile_parser, root, name, ambiguous_fun, hybrid_fun)</code>","text":"<p>NextstrainLikeNomenclature initialization.</p> <p>Parameters:</p> <ul> <li> <code>repo</code>               (<code>str</code>)           \u2013            <p>The username/repo combination for the GitHub repository storing this nomenclature.</p> </li> <li> <code>as_of</code>               (<code>date</code>)           \u2013            <p>Sets the as-of date in fulfillment of VersionedNomenclature.</p> </li> <li> <code>master_list</code>               (<code>str</code>)           \u2013            <p>The filepath, relative to <code>repo</code> where the master list of known names is available.</p> </li> <li> <code>master_list_parser</code>               (<code>Callable[[str], Collection[str]]</code>)           \u2013            <p>Used to extract the known taxa from the master list file.</p> </li> <li> <code>treefile</code>               (<code>str</code>)           \u2013            <p>The filepath, relative to <code>repo</code> where the tree of taxa is stored.</p> </li> <li> <code>treefile_parser</code>               (<code>Callable[[str], Tree]</code>)           \u2013            <p>Used to extract the tree of known taxa from the treefile.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of this nomenclature system.</p> </li> <li> <code>ambiguous_fun</code>               (<code>Callable</code>)           \u2013            <p>A Callable(name: str) -&gt; bool that takes in a name and returns whether or not it is ambiguous.</p> </li> <li> <code>hybrid_fun</code>               (<code>Callable</code>)           \u2013            <p>A Callable(name: str) -&gt; bool that takes in a name and returns whether or not it is a hybrid.</p> </li> <li> <code>root</code>               (<code>str</code>)           \u2013            <p>The name of the taxon that includes all others.</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def __init__(\n    self,\n    repo: str,\n    as_of: datetime.date,\n    master_list: str,\n    master_list_parser: Callable[[str], Collection[str]],\n    treefile: str,\n    treefile_parser: Callable[[str], dendropy.Tree],\n    root: str,\n    name: str,\n    ambiguous_fun: Callable,\n    hybrid_fun: Callable,\n):\n    \"\"\"\n    NextstrainLikeNomenclature initialization.\n\n    Parameters\n    ----------\n    repo : str\n        The username/repo combination for the GitHub repository storing this nomenclature.\n    as_of: datetime.date\n        Sets the as-of date in fulfillment of VersionedNomenclature.\n    master_list : str\n        The filepath, relative to `repo` where the master list of known names is available.\n    master_list_parser: Callable[[str], Collection[str]]\n        Used to extract the known taxa from the master list file.\n    treefile : str\n        The filepath, relative to `repo` where the tree of taxa is stored.\n    treefile_parser: Callable[[str], dendropy.Tree]\n        Used to extract the tree of known taxa from the treefile.\n    name : str\n        The name of this nomenclature system.\n    ambiguous_fun : Callable\n        A Callable(name: str) -&gt; bool that takes in a name and returns whether\n        or not it is ambiguous.\n    hybrid_fun : Callable\n        A Callable(name: str) -&gt; bool that takes in a name and returns whether\n        or not it is a hybrid.\n    root: str\n        The name of the taxon that includes all others.\n    \"\"\"\n    self.repo = repo\n    self._as_of = as_of\n    self.master_list = master_list\n    self.master_list_parser = master_list_parser\n    self.treefile = treefile\n    self.treefile_parser = treefile_parser\n    self.obtained_taxa = False\n    self.master_tree = None\n\n    super().__init__(\n        known_taxa=[],\n        root=root,\n        name=name,\n        ambiguous_fun=ambiguous_fun,\n        hybrid_fun=hybrid_fun,\n    )\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.NextstrainLikeNomenclature.populate_taxa","title":"<code>populate_taxa()</code>","text":"<p>Get taxa from GitHub repo. Separated from init so as not to call on startup.</p> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def populate_taxa(self):\n    \"\"\"\n    Get taxa from GitHub repo. Separated from __init__ so as not to call on startup.\n    \"\"\"\n    self.taxa = self.master_list_parser(\n        get_gh_file_contents_as_of(\n            self.repo, self.master_list, self.as_of()\n        )\n    )\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.NextstrainLikeNomenclature.populate_tree","title":"<code>populate_tree()</code>","text":"<p>Get tree from GitHub repo. Separated from init so as not to call on startup.</p> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def populate_tree(self):\n    \"\"\"\n    Get tree from GitHub repo. Separated from __init__ so as not to call on startup.\n    \"\"\"\n    self.master_tree = self.treefile_parser(\n        get_gh_file_contents_as_of(self.repo, self.treefile, self.as_of())\n    )\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.Nomenclature","title":"<code>Nomenclature</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract class for most general casting of Nomenclature</p> <p>Nomenclature concerns rules for naming taxa, and what names may imply about those taxa.</p> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>class Nomenclature(ABC):\n    \"\"\"\n    Abstract class for most general casting of Nomenclature\n\n    Nomenclature concerns rules for naming taxa, and what names may imply about\n    those taxa.\n    \"\"\"\n\n    @abstractmethod\n    def is_ambiguous(self, name: str) -&gt; bool:\n        \"\"\"\n        Does this name indicate an ambiguous taxon?\n\n        Ambiguity means a taxon specified only to a higher level than to which\n        resolution is possible.\n\n        Returns\n        -------\n        bool\n            True if this name indicates an ambiguous taxon.\n        \"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    def is_hybrid(self, name: str) -&gt; bool:\n        \"\"\"\n        Does this name indicate a hybrid?\n\n        Hybrid taxa have more than one parent taxon.\n\n        Parameters\n        ----------\n        name : string specifying name of the taxon\n\n        Returns\n        -------\n        bool\n            True if this name indicates a hybrid taxon.\n        \"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    def is_root(self, name: str) -&gt; bool:\n        \"\"\"\n        Does this string specify the root taxon?\n\n        The root taxon includes all taxa in the nomenclature scheme.\n\n        Parameters\n        ----------\n        name : string specifying name of the taxon\n\n        Returns\n        -------\n        bool\n            True if this name indicates the root taxon.\n        \"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    def is_valid_name(self, name: str) -&gt; bool:\n        \"\"\"\n        Is this name valid in the nomenclature scheme?\n\n        Parameters\n        ----------\n        name : string specifying name of the taxon\n\n        Returns\n        -------\n        bool\n            True if this is a valid name under the nomenclature.\n        \"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    def name(self) -&gt; str:\n        \"\"\"\n        Name of this nomenclature scheme.\n\n        Returns\n        -------\n        string\n            The name of this taxonomy scheme.\n        \"\"\"\n        raise NotImplementedError()\n\n    def validate(self, names: Iterable[str]) -&gt; None:\n        nonstr = [name for name in names if not isinstance(name, str)]\n        if len(nonstr) &gt; 0:\n            raise TypeError(f\"Found non-string names: {nonstr}\")\n        invalid = [name for name in names if not self.is_valid_name(name)]\n        if len(invalid) &gt; 0:\n            raise ValueError(\n                f\"The following names are invalid under the provided Nomenclature ({self.name()}): {invalid}\"\n            )\n\n    def __str__(self):\n        return self.name()\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.Nomenclature.is_ambiguous","title":"<code>is_ambiguous(name)</code>  <code>abstractmethod</code>","text":"<p>Does this name indicate an ambiguous taxon?</p> <p>Ambiguity means a taxon specified only to a higher level than to which resolution is possible.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if this name indicates an ambiguous taxon.</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>@abstractmethod\ndef is_ambiguous(self, name: str) -&gt; bool:\n    \"\"\"\n    Does this name indicate an ambiguous taxon?\n\n    Ambiguity means a taxon specified only to a higher level than to which\n    resolution is possible.\n\n    Returns\n    -------\n    bool\n        True if this name indicates an ambiguous taxon.\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.Nomenclature.is_hybrid","title":"<code>is_hybrid(name)</code>  <code>abstractmethod</code>","text":"<p>Does this name indicate a hybrid?</p> <p>Hybrid taxa have more than one parent taxon.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>string specifying name of the taxon</code>)           \u2013            </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if this name indicates a hybrid taxon.</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>@abstractmethod\ndef is_hybrid(self, name: str) -&gt; bool:\n    \"\"\"\n    Does this name indicate a hybrid?\n\n    Hybrid taxa have more than one parent taxon.\n\n    Parameters\n    ----------\n    name : string specifying name of the taxon\n\n    Returns\n    -------\n    bool\n        True if this name indicates a hybrid taxon.\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.Nomenclature.is_root","title":"<code>is_root(name)</code>  <code>abstractmethod</code>","text":"<p>Does this string specify the root taxon?</p> <p>The root taxon includes all taxa in the nomenclature scheme.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>string specifying name of the taxon</code>)           \u2013            </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if this name indicates the root taxon.</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>@abstractmethod\ndef is_root(self, name: str) -&gt; bool:\n    \"\"\"\n    Does this string specify the root taxon?\n\n    The root taxon includes all taxa in the nomenclature scheme.\n\n    Parameters\n    ----------\n    name : string specifying name of the taxon\n\n    Returns\n    -------\n    bool\n        True if this name indicates the root taxon.\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.Nomenclature.is_valid_name","title":"<code>is_valid_name(name)</code>  <code>abstractmethod</code>","text":"<p>Is this name valid in the nomenclature scheme?</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>string specifying name of the taxon</code>)           \u2013            </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if this is a valid name under the nomenclature.</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>@abstractmethod\ndef is_valid_name(self, name: str) -&gt; bool:\n    \"\"\"\n    Is this name valid in the nomenclature scheme?\n\n    Parameters\n    ----------\n    name : string specifying name of the taxon\n\n    Returns\n    -------\n    bool\n        True if this is a valid name under the nomenclature.\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.Nomenclature.name","title":"<code>name()</code>  <code>abstractmethod</code>","text":"<p>Name of this nomenclature scheme.</p> <p>Returns:</p> <ul> <li> <code>string</code>           \u2013            <p>The name of this taxonomy scheme.</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>@abstractmethod\ndef name(self) -&gt; str:\n    \"\"\"\n    Name of this nomenclature scheme.\n\n    Returns\n    -------\n    string\n        The name of this taxonomy scheme.\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.NomenclatureVersioner","title":"<code>NomenclatureVersioner</code>","text":"<p>               Bases: <code>ABC</code></p> <p>In general: a Callable such that NomenclatureVersioner(name: str) -&gt; bool specifies whether the name was recognized as of a previous iteration of the nomenclature. Specifically, works via an exhaustive list of known taxa at that time.</p> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>class NomenclatureVersioner(ABC):\n    \"\"\"\n    In general: a Callable such that NomenclatureVersioner(name: str) -&gt; bool\n    specifies whether the name was recognized as of a previous iteration of the\n    nomenclature. Specifically, works via an exhaustive list of known taxa at\n    that time.\n    \"\"\"\n\n    def __init__(self, names: Collection[str]):\n        \"\"\"\n        NomenclatureVersioner initialization from list of known taxa.\n        \"\"\"\n        self.names = names\n\n    def __call__(self, name: str) -&gt; bool:\n        return name in self.names\n\n    @classmethod\n    def from_gh_file(\n        cls,\n        repo: str,\n        file_path: str,\n        as_of: datetime.date,\n        extractor: Callable[[str], Collection[str]],\n    ):\n        \"\"\"\n        Gets the versioned list of known taxa as of date `as_of` from a file in a GitHub repo.\n\n        Parameters\n        ---------\n        repo : str\n            The username/repo combination.\n        file_path : str\n            Relative path to file from repo root.\n        as_of: datetime.date\n            The as-of date for getting the file.\n        extractor: Callable[[str], Collection[str]]\n            A function that processes the read GitHub file and returns the known taxa.\n        \"\"\"\n        file_content = get_gh_file_contents_as_of(repo, file_path, as_of)\n        return cls(extractor(file_content))\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.NomenclatureVersioner.__init__","title":"<code>__init__(names)</code>","text":"<p>NomenclatureVersioner initialization from list of known taxa.</p> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def __init__(self, names: Collection[str]):\n    \"\"\"\n    NomenclatureVersioner initialization from list of known taxa.\n    \"\"\"\n    self.names = names\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.NomenclatureVersioner.from_gh_file","title":"<code>from_gh_file(repo, file_path, as_of, extractor)</code>  <code>classmethod</code>","text":"<p>Gets the versioned list of known taxa as of date <code>as_of</code> from a file in a GitHub repo.</p> <p>Parameters:</p> <ul> <li> <code>repo</code>               (<code>str</code>)           \u2013            <p>The username/repo combination.</p> </li> <li> <code>file_path</code>               (<code>str</code>)           \u2013            <p>Relative path to file from repo root.</p> </li> <li> <code>as_of</code>               (<code>date</code>)           \u2013            <p>The as-of date for getting the file.</p> </li> <li> <code>extractor</code>               (<code>Callable[[str], Collection[str]]</code>)           \u2013            <p>A function that processes the read GitHub file and returns the known taxa.</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>@classmethod\ndef from_gh_file(\n    cls,\n    repo: str,\n    file_path: str,\n    as_of: datetime.date,\n    extractor: Callable[[str], Collection[str]],\n):\n    \"\"\"\n    Gets the versioned list of known taxa as of date `as_of` from a file in a GitHub repo.\n\n    Parameters\n    ---------\n    repo : str\n        The username/repo combination.\n    file_path : str\n        Relative path to file from repo root.\n    as_of: datetime.date\n        The as-of date for getting the file.\n    extractor: Callable[[str], Collection[str]]\n        A function that processes the read GitHub file and returns the known taxa.\n    \"\"\"\n    file_content = get_gh_file_contents_as_of(repo, file_path, as_of)\n    return cls(extractor(file_content))\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.PangoLikeNomenclature","title":"<code>PangoLikeNomenclature</code>","text":"<p>               Bases: <code>AlgorithmicNomenclature</code></p> <p>A Pango-like nomenclature is an AlgorithmicNomenclature with more specific assumptions about the encoding of history.</p> <p>Specifically, we assume that the name encodes the history in a string such that the name is a series of (sub)levels denoted by a consistent set of characters (say, digits) separated by a consistent separator (say, r\".\"). The first portion of the name is assumed to be an alias, which is a set of different characters (say, upper case letters) which serve as shorthand for a longer series of levels. The alias is allowed to be cumulative (such as in RSV nomenclature) or not (such as in Pango nomenclature).</p> <p>An external file storing the alias shortcuts is required.</p> <p>This class is partially abstract and should not directly be used to initialize Nomenclature objects.</p> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>class PangoLikeNomenclature(AlgorithmicNomenclature):\n    \"\"\"\n    A Pango-like nomenclature is an AlgorithmicNomenclature with more specific\n    assumptions about the encoding of history.\n\n    Specifically, we assume that the name encodes the history in a string such\n    that the name is a series of (sub)levels denoted by a consistent set of\n    characters (say, digits) separated by a consistent separator (say, r\".\").\n    The first portion of the name is assumed to be an alias, which is a set of\n    different characters (say, upper case letters) which serve as shorthand\n    for a longer series of levels. The alias is allowed to be cumulative (such\n    as in RSV nomenclature) or not (such as in Pango nomenclature).\n\n    An external file storing the alias shortcuts is required.\n\n    This class is partially abstract and should not directly be used to initialize\n    Nomenclature objects.\n    \"\"\"\n\n    def __init__(\n        self,\n        alias_map_hybrid: Collection[type],\n        charsets: Sequence[set],\n        cumulative_alias: bool,\n        max_sublevels: int,\n        root: str,\n        sep: str,\n        special: Container,\n        name: str,\n    ):\n        \"\"\"\n        Initialization of PangoLikeNomenclature objects.\n\n        Parameters\n        ----------\n        alias_map_hybrid : Collection[type]\n            Container type(s) used in alias map when hybrid ancestry is indicated.\n        charsets : Sequence[set]\n            Defines what's allowed in alias names [0] and sublevel names [1]\n        cumulative_alias: bool\n            Does the alias accumulate (like RSV system) or not (like Pango)\n        max_sublevels : int\n            Defines maximum number of sublevels before aliasing must be done, 3 for\n            Pango SARS-CoV-2.\n        root : str\n            Name for the root taxon. If not explicitly specified by naming system,\n            anything that will not conflict with other taxon names could be used.\n        sep : str\n            Defines what separates the levels of the name, \".\" in Pango and RSV.\n        special : Container\n            Defines what aliases are allowed to appear alone, such as \"A\" in Pango\n            SARS-CoV-2.\n        name : str\n            The name of this nomenclature system, e.g. PangoNomenclature(SARS-CoV-2).\n        \"\"\"\n        self.alias_map_hybrid: Collection[type] = alias_map_hybrid\n        self.charsets: Sequence[set] = charsets\n        self.cumulative_alias: bool = cumulative_alias\n        self.max_sublevels: int = max_sublevels\n        self.root: str = root\n        self.sep: str = sep\n        self.special: Container = special\n        self._name: str = name\n\n        self.alias_map: dict = {}\n        \"Defines mapping to make longer names from shorter ones\"\n        self.alias_map_inv: dict = {}\n        \"Defines mapping to make shorter names from longer ones\"\n\n    ##############################\n    # Superclass implementations #\n    ##############################\n\n    def full_histories(\n        self, taxa: Sequence[str], stop_at_hybrid: bool = False\n    ) -&gt; Sequence[Sequence[str]]:\n        if stop_at_hybrid:\n            raise NotImplementedError(\n                \"Forests of histories are not currently implemented or supported.\"\n            )\n        return [self.get_history(taxon, stop_at_hybrid) for taxon in taxa]\n\n    def is_root(self, name: str) -&gt; bool:\n        return name == self.root\n\n    def is_valid_name(\n        self,\n        name: str,\n        min_sublevels: int = 1,\n        max_sublevels: Optional[int] = None,\n    ) -&gt; bool:\n        parts = self.partition_name(name)\n        # Check aliasing portion of name\n        n_alias = len(parts[0])\n        if n_alias &lt; 1:\n            return False\n        if n_alias &gt; 1 and not self.cumulative_alias:\n            return False\n        for a in parts[0]:\n            if not set(a) &lt; self.charsets[0]:\n                return False\n        # Check sublevels\n        n_lvl = len(parts[1])\n        if n_lvl &lt; min_sublevels:\n            return False\n        if max_sublevels is None:\n            if n_lvl &gt; self.max_sublevels:\n                return False\n        elif n_lvl &gt; max_sublevels:\n            return False\n        for lvl in parts[1]:\n            if not set(lvl) &lt; self.charsets[1]:\n                return False\n        return True\n\n    def name(self) -&gt; str:\n        return self._name\n\n    ########################\n    # Superclass overrides #\n    ########################\n\n    def taxonomy_tree(\n        self,\n        taxa: Sequence[Taxon],\n        insert_tips: bool = True,\n        warn: bool = True,\n    ) -&gt; dendropy.Tree:\n        return super().taxonomy_tree(\n            taxa=taxa,\n            insert_tips=insert_tips,\n            name_cleanup_fun=self.coax_name,\n            warn=warn,\n        )\n\n    #################\n    # Class methods #\n    #################\n\n    def coax_name(self, name: str) -&gt; str:\n        \"\"\"\n        Coax a potentially too-short or too-long name to proper format.\n\n        For example, we might coax the SARS-CoV-2 Pango name from\n        B.1.1.529.2.86.1.1.11.1.3 (which encodes the entire history but is too)\n        long under the scheme to be proper, to KP.3. Alternately, we might coax\n        the too-short KP to JN.1.11.1\n\n        Parameters\n        ----------\n        name : str\n            The name of the taxon.\n\n        Returns\n        -------\n        str\n            The name, without too many or too few sublevels.\n        \"\"\"\n        if self.is_root(name):\n            return name\n        return self.shorter_name(self.longer_name(name))\n\n    def equals_ignore_alias(self, x: str, y: str) -&gt; bool:\n        \"\"\"\n        Are two names the same, accounting for aliasing?\n\n        For example, the Pango SARS-CoV-2 names JN.1.11.1.3 and KP.3 both\n        encode the history of the same taxon, KP3.\n\n        Parameters\n        ----------\n        x : str\n            A taxon's name.\n        y : str\n            A putatively equivalent name for the taxon\n\n        Returns\n        -------\n        bool\n            Are the names the same ignoring aliasing?\n        \"\"\"\n        return self.longer_name(x) == self.longer_name(y)\n\n    def get_history(self, name: str, stop_at_hybrid: bool) -&gt; Sequence[str]:\n        \"\"\"\n        Get a path of ancestry from the root to this taxon.\n\n        This is different than a long-form name because it allows us to pass\n        through hybridization (recombination) events. In the face of\n        recombination, when stop_at_hybrid == False, we follow the ancestry of\n        the 5'-most portion of the genome.\n\n        Parameters\n        ----------\n        name : str\n            A taxon's name.\n        stop_at_hybrid : bool\n            If True, we get the history up to the most recent hybrid ancestor.\n            If False, we follow the ancestry of the 5'-most portion of the genome\n            through all hybrid ancestors.\n\n        Returns\n        -------\n        Sequence[str]\n            This taxon's ancestors, starting from root-most.\n        \"\"\"\n        if not self.alias_map:\n            raise RuntimeError(\n                \"Cannot obtain histories until setup_alias_map() has been called.\"\n            )\n        if not self.is_valid_name(name):\n            raise ValueError(name + \" is not a valid name in \" + self.name())\n        history = []\n        self.extend_history(name, history, stop_at_hybrid)\n        history.reverse()\n        return history\n\n    def extend_history(\n        self, name: str, history: MutableSequence[str], stop_at_hybrid: bool\n    ) -&gt; None:\n        \"\"\"\n        Recursively extend a path of ancestry from this taxon to the root.\n\n        Parameters\n        ----------\n        name : str\n            A taxon's name.\n        history : MutableSequence[str]\n            The history we are in the process of building\n        stop_at_hybrid : bool\n            Should we consider hybridization to start a new tree or not? If\n            not, we break hybridization by following the first listed parent.\n\n        Returns\n        -------\n        None\n            Adds history to the history argument and then returns or calls\n            itself if not done.\n        \"\"\"\n        name = self.longer_name(name)\n        comp = self.partition_name(name)\n        if not comp[0]:\n            raise ValueError(\"Invalid name: \" + name)\n        # Digest sublevels\n        if comp[1]:\n            for i in range(1, len(comp[1]) + 1)[::-1]:\n                history.append(self.unpartition_name([comp[0], comp[1][:i]]))\n        # Handle alias\n        alias = self.join(comp[0])\n        if self.is_root(alias):\n            history.append(self.root)\n        else:\n            if self.is_special(alias):\n                history.append(alias)\n            if not self.is_hybrid(alias):\n                self.extend_history(\n                    self.alias_map[alias], history, stop_at_hybrid\n                )\n            elif not stop_at_hybrid:\n                self.extend_history(\n                    self.alias_map[alias][0], history, stop_at_hybrid\n                )\n\n    def invert_map(self) -&gt; None:\n        \"\"\"\n        Inverts the shorter-&gt;longer self.alias_map\n\n        The inverted alias map is incapable of handling hybridization.\n\n        Returns\n        -------\n        None\n            The inverted map is stored as self.alias_map_inv\n        \"\"\"\n        rev_map = {}\n        for k, v in self.alias_map.items():\n            if not isinstance(v, list):\n                v = [v]\n            for vi in v:\n                # Don't add empty root alias\n                if (not self.is_root(vi)) and (not self.is_hybrid(k)):\n                    if vi in rev_map:\n                        raise RuntimeError(\n                            \"Alias list cannot be inverted. \"\n                            + \"Trying to add inverse alias for \"\n                            + vi\n                            + \", which is an alias of \"\n                            + k\n                            + \", but reversed map already has it\"\n                        )\n                    rev_map[vi] = k\n        self.alias_map_inv = rev_map\n\n    def is_alias_map_hybrid(self, alias_value: Any) -&gt; bool:\n        \"\"\"\n        Is this lineage a hybrid according to the alias map?\n\n        Checks whether a value (rather than a key) from an alias map indicates\n        a taxon has hybrid ancestry by checking if it is a container.\n\n        Parameters\n        ----------\n        alias_value : the value (as opposed to the key) for some taxon in\n            self.alias_map, i.e., self.alias_map[&lt;some key&gt;]\n\n        Returns\n        -------\n        bool\n            True if the alias map indicates this is a hybrid.\n        \"\"\"\n        for t in self.alias_map_hybrid:\n            if isinstance(alias_value, t):\n                return True\n        return False\n\n    @abstractmethod\n    def is_special(self, name: str) -&gt; bool:\n        \"\"\"\n        Is this a recognized special-purpose ancestor?\n\n        Special-purpose ancestors are allowed to be used with 0 sublevels.\n\n        Under the Pango nomenclature, direct root descendants and recombinants\n        are special-purpose ancestors. Thus for Pango SARS-CoV-2, a special\n        lineage is A, B, or any recombinant such as XBB (but not a descendant,\n        such as XBB.1).\n\n        Parameters\n        ----------\n        name : str\n            A taxon's name.\n\n        Returns\n        -------\n        bool\n            True if this taxon is a special taxon.\n        \"\"\"\n        raise NotImplementedError()\n\n    def is_valid_alias(self, alias: str) -&gt; bool:\n        \"\"\"\n        Does this string specify a valid shortcut/alias for a taxon's history?\n\n        A valid alias should contain only characters allowed in the aliasing\n        portion of the name, possibly with separators if the alias is\n        cumulative.\n\n        Parameters\n        ----------\n        alias : str\n            String to be checked for validity as alias.\n\n        Returns\n        -------\n        bool\n            True if this is a valid alias.\n        \"\"\"\n        if self.cumulative_alias:\n            return all([set(a) &lt; self.charsets[0] for a in self.split(alias)])\n        else:\n            return set(alias) &lt; self.charsets[0]\n\n    def join(self, comp: Sequence[str]) -&gt; str:\n        \"\"\"\n        Join list of component levels into name.\n\n        The inverse of self.split(name), such that\n        self.join(self.split(name)) == name.\n\n        Parameters\n        ----------\n        comp : Sequence[str]\n            Components of a taxon's name.\n\n        Returns\n        -------\n        str\n            The name a a single string.\n        \"\"\"\n        return self.sep.join(comp)\n\n    def longer_name(self, name: str) -&gt; str:\n        \"\"\"\n        Get non-aliased form of an aliased name.\n\n        A long-form name stops at the most recent hybridization event in a\n        taxon's ancestry if there is such an event, otherwise at the special\n        root descendent taxa.\n\n        For example, the Pango SARS-CoV-2 taxon JN.1.11 would become\n        B.1.1.529.2.86.1.1.11.\n\n        Parameters\n        ----------\n        name : str\n            A taxon's name.\n\n        Returns\n        -------\n        str\n            The taxon's name in the longest form of history.\n        \"\"\"\n        if not self.alias_map:\n            raise RuntimeError(\n                \"Cannot construct long form of name without an alias list.\"\n            )\n        if self.is_root(name):\n            return name\n        alias_levels = list(self.partition_name(name))\n        next_alias = self.alias_map[alias_levels[0][-1]]\n        while not self.is_root(next_alias) and (\n            not self.is_hybrid(alias_levels[0][-1])\n        ):\n            parts = self.partition_name(next_alias)\n            alias_levels[0] = parts[0]\n            alias_levels[1] = [*parts[1], *alias_levels[1]]\n            next_alias = self.alias_map[parts[0][-1]]\n        return self.unpartition_name(alias_levels)\n\n    def next_shorter_alias(self, name: str, depth: int) -&gt; str:\n        \"\"\"\n        Get the next shortest name available to a taxon.\n\n        This removes one \"layer\" of self.max_sublevels from a name. For\n        example, the Pango SARS-CoV-2 lineage B.1.1.529.2.86.1.1.11 would\n        become BA.2.86.1.1.11 because BA is an alias for B.1.1.529.\n\n        Parameters\n        ----------\n        name : str\n            A expanded taxon name to be contracted\n        depth : int\n            How many levels of aliasing deep is this name? Starting at 1 for\n            longest (fully de-aliased) name and increasing as the name gets\n            shorter.\n\n        Returns\n        -------\n        str\n            The taxon's name with one fewer levels of aliasing.\n        \"\"\"\n\n        parts = self.partition_name(name)\n        n = self.max_sublevels * depth\n        alias = None\n        for k, v in self.alias_map_inv.items():\n            kl = self.partition_name(k)\n            if (\n                kl[1] == parts[1]\n                or self.partition_name(self.longer_name(k))[1][:n]\n                == self.partition_name(self.longer_name(name))[1][:n]\n            ):\n                alias = v\n                break\n        if not alias:\n            raise RuntimeError(\"Cannot find shorter alias for \" + name)\n        return alias\n\n    def num_sublevels(self, name: str) -&gt; int:\n        \"\"\"\n        How many sublevels does this name contain?\n\n        For a Pango SARS-CoV-2 example, the names XBB, XBB.1, XBB.1.5, and\n        XBB.1.5.39 contain 0, 1, 2, and 3 sublevels respectively.\n\n        Parameters\n        ----------\n        name : str\n            The taxon's name.\n\n        Returns\n        -------\n        int\n            The number of sublevels the name contains.\n        \"\"\"\n        return len(self.partition_name(name)[1])\n\n    def partition_name(self, name: str) -&gt; Sequence[Sequence[str]]:\n        \"\"\"\n        Splits name into alias and sublevels, each as a sequence of components\n\n        This function assumes that the name is ordered alias, sublevels, and does not check correctness.\n\n        Parameters\n        ----------\n        name : str\n            The taxon's name to be partitioned.\n\n        Returns\n        -------\n        Sequence[Sequence[str]]\n            First element is Sequence of components in the aliasing portion of\n            the taxon's name, second element is Sequence of sublevels.\n        \"\"\"\n        comp = self.split(name)\n        if not self.cumulative_alias:\n            alias = [] if len(comp) == 0 else [comp[0]]\n            sublevels = [] if len(comp) &lt; 2 else comp[1:]\n            return [alias, sublevels]\n\n        if not (set(comp[-1]) &lt; self.charsets[1]):\n            return [comp, []]\n        if not (set(comp[0]) &lt; self.charsets[0]):\n            return [[], comp]\n        n = 1\n        while set(comp[-n]) &lt; self.charsets[1]:\n            n += 1\n\n        alias = [comp[0]] if n == len(comp) else comp[: (len(comp) - n + 1)]\n        sublevels = [comp[-1]] if n == 1 else comp[(len(comp) - n + 1) :]\n        return [alias, sublevels]\n\n    def sanitize_map(self) -&gt; None:\n        \"\"\"\n        Drop ambiguity markers and check all names are valid.\n\n        For the purposes of determining ancestry, an unknown sublineage is\n            effectively just its ancestor, and we treat it as such.\n\n        Returns\n        -------\n        None\n            Modifies self.alias_map in-place\n        \"\"\"\n        if not self.alias_map:\n            raise RuntimeError(\n                \"Missing self.alias_map when trying to sanitize.\"\n            )\n\n        for k, v in self.alias_map.items():\n            if not self.is_valid_alias(k):\n                raise RuntimeError(\n                    \"Found invalid taxon as key in alias list: \" + k\n                )\n            if self.is_ambiguous(k):\n                raise RuntimeError(\n                    \"Found ambiguous taxon as key in alias list: \" + k\n                )\n            if not self.is_alias_map_hybrid(v):\n                if self.is_root(v):\n                    if not self.is_special(k):\n                        raise RuntimeError(\n                            'Found alias for root in taxon not listed as special: \"'\n                            + k\n                            + '\"'\n                        )\n                else:\n                    v = [v]\n            for i in range(len(v)):\n                if self.is_ambiguous(v[i]):\n                    v[i] = v[i][:-1]\n                if not self.is_valid_name(v[i], max_sublevels=integer_inf):\n                    raise RuntimeError(\n                        'Found invalid taxon as value in alias list: \"'\n                        + v[i]\n                        + '\" (for key \"'\n                        + k\n                        + '\")'\n                    )\n\n    def shorter_name(self, name: str) -&gt; str:\n        \"\"\"\n        Get shortest form of a maximally-long name using aliases\n\n        For example, the SARS-CoV-2 Pango name B.1.1.529.2.86.1.1.11.1.3 will\n        be made into KP.3, and B.1.1.529.2.86.1.1.11.1 will be made into\n        JN.1.11.1. Both of these are the shortest-possible valid forms of the\n        names, having neither too many nor too few sublevels.\n\n        Parameters\n        ----------\n        name : str\n            The taxon's name to be shortened.\n\n        Returns\n        -------\n        str\n            Shortest valid form of the name for this taxon.\n        \"\"\"\n        if not self.alias_map:\n            raise RuntimeError(\n                \"Cannot get shorter name without an alias list.\"\n            )\n        comp = list(self.partition_name(name))\n        lvl = 1\n        while len(comp[1]) &gt; self.max_sublevels:\n            alias = self.next_shorter_alias(self.unpartition_name(comp), lvl)\n            comp[0] = [alias]\n            comp[1] = comp[1][3:]\n            lvl += 1\n        return self.unpartition_name(comp)\n\n    def split(self, name: str) -&gt; Sequence[str]:\n        \"\"\"\n        Split name into component levels\n\n        The inverse of self.join(name), such that\n        self.split(self.join(components)) == components.\n\n        Parameters\n        ----------\n        name : str\n            The name a a single string.\n\n        Returns\n        -------\n        Sequence[str]\n            Components of a taxon's name.\n        \"\"\"\n        return name.split(self.sep)\n\n    def unpartition_name(self, components: Sequence[Sequence[str]]) -&gt; str:\n        \"\"\"\n        Undoes partition_name\n\n        Parameters\n        ----------\n        components : Sequence[Sequence[str]]\n            First element is Sequence of components in the aliasing portion of\n            the taxon's name, second element is Sequence of sublevels.\n\n        Returns\n        -------\n        str\n            The taxon's name as a single string.\n        \"\"\"\n        return self.join([*components[0], *components[1]])\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.PangoLikeNomenclature.alias_map","title":"<code>alias_map = {}</code>  <code>instance-attribute</code>","text":"<p>Defines mapping to make longer names from shorter ones</p>"},{"location":"api/#cladecombiner.nomenclature.PangoLikeNomenclature.alias_map_inv","title":"<code>alias_map_inv = {}</code>  <code>instance-attribute</code>","text":"<p>Defines mapping to make shorter names from longer ones</p>"},{"location":"api/#cladecombiner.nomenclature.PangoLikeNomenclature.__init__","title":"<code>__init__(alias_map_hybrid, charsets, cumulative_alias, max_sublevels, root, sep, special, name)</code>","text":"<p>Initialization of PangoLikeNomenclature objects.</p> <p>Parameters:</p> <ul> <li> <code>alias_map_hybrid</code>               (<code>Collection[type]</code>)           \u2013            <p>Container type(s) used in alias map when hybrid ancestry is indicated.</p> </li> <li> <code>charsets</code>               (<code>Sequence[set]</code>)           \u2013            <p>Defines what's allowed in alias names [0] and sublevel names [1]</p> </li> <li> <code>cumulative_alias</code>               (<code>bool</code>)           \u2013            <p>Does the alias accumulate (like RSV system) or not (like Pango)</p> </li> <li> <code>max_sublevels</code>               (<code>int</code>)           \u2013            <p>Defines maximum number of sublevels before aliasing must be done, 3 for Pango SARS-CoV-2.</p> </li> <li> <code>root</code>               (<code>str</code>)           \u2013            <p>Name for the root taxon. If not explicitly specified by naming system, anything that will not conflict with other taxon names could be used.</p> </li> <li> <code>sep</code>               (<code>str</code>)           \u2013            <p>Defines what separates the levels of the name, \".\" in Pango and RSV.</p> </li> <li> <code>special</code>               (<code>Container</code>)           \u2013            <p>Defines what aliases are allowed to appear alone, such as \"A\" in Pango SARS-CoV-2.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of this nomenclature system, e.g. PangoNomenclature(SARS-CoV-2).</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def __init__(\n    self,\n    alias_map_hybrid: Collection[type],\n    charsets: Sequence[set],\n    cumulative_alias: bool,\n    max_sublevels: int,\n    root: str,\n    sep: str,\n    special: Container,\n    name: str,\n):\n    \"\"\"\n    Initialization of PangoLikeNomenclature objects.\n\n    Parameters\n    ----------\n    alias_map_hybrid : Collection[type]\n        Container type(s) used in alias map when hybrid ancestry is indicated.\n    charsets : Sequence[set]\n        Defines what's allowed in alias names [0] and sublevel names [1]\n    cumulative_alias: bool\n        Does the alias accumulate (like RSV system) or not (like Pango)\n    max_sublevels : int\n        Defines maximum number of sublevels before aliasing must be done, 3 for\n        Pango SARS-CoV-2.\n    root : str\n        Name for the root taxon. If not explicitly specified by naming system,\n        anything that will not conflict with other taxon names could be used.\n    sep : str\n        Defines what separates the levels of the name, \".\" in Pango and RSV.\n    special : Container\n        Defines what aliases are allowed to appear alone, such as \"A\" in Pango\n        SARS-CoV-2.\n    name : str\n        The name of this nomenclature system, e.g. PangoNomenclature(SARS-CoV-2).\n    \"\"\"\n    self.alias_map_hybrid: Collection[type] = alias_map_hybrid\n    self.charsets: Sequence[set] = charsets\n    self.cumulative_alias: bool = cumulative_alias\n    self.max_sublevels: int = max_sublevels\n    self.root: str = root\n    self.sep: str = sep\n    self.special: Container = special\n    self._name: str = name\n\n    self.alias_map: dict = {}\n    \"Defines mapping to make longer names from shorter ones\"\n    self.alias_map_inv: dict = {}\n    \"Defines mapping to make shorter names from longer ones\"\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.PangoLikeNomenclature.coax_name","title":"<code>coax_name(name)</code>","text":"<p>Coax a potentially too-short or too-long name to proper format.</p> <p>For example, we might coax the SARS-CoV-2 Pango name from B.1.1.529.2.86.1.1.11.1.3 (which encodes the entire history but is too) long under the scheme to be proper, to KP.3. Alternately, we might coax the too-short KP to JN.1.11.1</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the taxon.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The name, without too many or too few sublevels.</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def coax_name(self, name: str) -&gt; str:\n    \"\"\"\n    Coax a potentially too-short or too-long name to proper format.\n\n    For example, we might coax the SARS-CoV-2 Pango name from\n    B.1.1.529.2.86.1.1.11.1.3 (which encodes the entire history but is too)\n    long under the scheme to be proper, to KP.3. Alternately, we might coax\n    the too-short KP to JN.1.11.1\n\n    Parameters\n    ----------\n    name : str\n        The name of the taxon.\n\n    Returns\n    -------\n    str\n        The name, without too many or too few sublevels.\n    \"\"\"\n    if self.is_root(name):\n        return name\n    return self.shorter_name(self.longer_name(name))\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.PangoLikeNomenclature.equals_ignore_alias","title":"<code>equals_ignore_alias(x, y)</code>","text":"<p>Are two names the same, accounting for aliasing?</p> <p>For example, the Pango SARS-CoV-2 names JN.1.11.1.3 and KP.3 both encode the history of the same taxon, KP3.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>str</code>)           \u2013            <p>A taxon's name.</p> </li> <li> <code>y</code>               (<code>str</code>)           \u2013            <p>A putatively equivalent name for the taxon</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Are the names the same ignoring aliasing?</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def equals_ignore_alias(self, x: str, y: str) -&gt; bool:\n    \"\"\"\n    Are two names the same, accounting for aliasing?\n\n    For example, the Pango SARS-CoV-2 names JN.1.11.1.3 and KP.3 both\n    encode the history of the same taxon, KP3.\n\n    Parameters\n    ----------\n    x : str\n        A taxon's name.\n    y : str\n        A putatively equivalent name for the taxon\n\n    Returns\n    -------\n    bool\n        Are the names the same ignoring aliasing?\n    \"\"\"\n    return self.longer_name(x) == self.longer_name(y)\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.PangoLikeNomenclature.extend_history","title":"<code>extend_history(name, history, stop_at_hybrid)</code>","text":"<p>Recursively extend a path of ancestry from this taxon to the root.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>A taxon's name.</p> </li> <li> <code>history</code>               (<code>MutableSequence[str]</code>)           \u2013            <p>The history we are in the process of building</p> </li> <li> <code>stop_at_hybrid</code>               (<code>bool</code>)           \u2013            <p>Should we consider hybridization to start a new tree or not? If not, we break hybridization by following the first listed parent.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>Adds history to the history argument and then returns or calls itself if not done.</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def extend_history(\n    self, name: str, history: MutableSequence[str], stop_at_hybrid: bool\n) -&gt; None:\n    \"\"\"\n    Recursively extend a path of ancestry from this taxon to the root.\n\n    Parameters\n    ----------\n    name : str\n        A taxon's name.\n    history : MutableSequence[str]\n        The history we are in the process of building\n    stop_at_hybrid : bool\n        Should we consider hybridization to start a new tree or not? If\n        not, we break hybridization by following the first listed parent.\n\n    Returns\n    -------\n    None\n        Adds history to the history argument and then returns or calls\n        itself if not done.\n    \"\"\"\n    name = self.longer_name(name)\n    comp = self.partition_name(name)\n    if not comp[0]:\n        raise ValueError(\"Invalid name: \" + name)\n    # Digest sublevels\n    if comp[1]:\n        for i in range(1, len(comp[1]) + 1)[::-1]:\n            history.append(self.unpartition_name([comp[0], comp[1][:i]]))\n    # Handle alias\n    alias = self.join(comp[0])\n    if self.is_root(alias):\n        history.append(self.root)\n    else:\n        if self.is_special(alias):\n            history.append(alias)\n        if not self.is_hybrid(alias):\n            self.extend_history(\n                self.alias_map[alias], history, stop_at_hybrid\n            )\n        elif not stop_at_hybrid:\n            self.extend_history(\n                self.alias_map[alias][0], history, stop_at_hybrid\n            )\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.PangoLikeNomenclature.get_history","title":"<code>get_history(name, stop_at_hybrid)</code>","text":"<p>Get a path of ancestry from the root to this taxon.</p> <p>This is different than a long-form name because it allows us to pass through hybridization (recombination) events. In the face of recombination, when stop_at_hybrid == False, we follow the ancestry of the 5'-most portion of the genome.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>A taxon's name.</p> </li> <li> <code>stop_at_hybrid</code>               (<code>bool</code>)           \u2013            <p>If True, we get the history up to the most recent hybrid ancestor. If False, we follow the ancestry of the 5'-most portion of the genome through all hybrid ancestors.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Sequence[str]</code>           \u2013            <p>This taxon's ancestors, starting from root-most.</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def get_history(self, name: str, stop_at_hybrid: bool) -&gt; Sequence[str]:\n    \"\"\"\n    Get a path of ancestry from the root to this taxon.\n\n    This is different than a long-form name because it allows us to pass\n    through hybridization (recombination) events. In the face of\n    recombination, when stop_at_hybrid == False, we follow the ancestry of\n    the 5'-most portion of the genome.\n\n    Parameters\n    ----------\n    name : str\n        A taxon's name.\n    stop_at_hybrid : bool\n        If True, we get the history up to the most recent hybrid ancestor.\n        If False, we follow the ancestry of the 5'-most portion of the genome\n        through all hybrid ancestors.\n\n    Returns\n    -------\n    Sequence[str]\n        This taxon's ancestors, starting from root-most.\n    \"\"\"\n    if not self.alias_map:\n        raise RuntimeError(\n            \"Cannot obtain histories until setup_alias_map() has been called.\"\n        )\n    if not self.is_valid_name(name):\n        raise ValueError(name + \" is not a valid name in \" + self.name())\n    history = []\n    self.extend_history(name, history, stop_at_hybrid)\n    history.reverse()\n    return history\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.PangoLikeNomenclature.invert_map","title":"<code>invert_map()</code>","text":"<p>Inverts the shorter-&gt;longer self.alias_map</p> <p>The inverted alias map is incapable of handling hybridization.</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>The inverted map is stored as self.alias_map_inv</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def invert_map(self) -&gt; None:\n    \"\"\"\n    Inverts the shorter-&gt;longer self.alias_map\n\n    The inverted alias map is incapable of handling hybridization.\n\n    Returns\n    -------\n    None\n        The inverted map is stored as self.alias_map_inv\n    \"\"\"\n    rev_map = {}\n    for k, v in self.alias_map.items():\n        if not isinstance(v, list):\n            v = [v]\n        for vi in v:\n            # Don't add empty root alias\n            if (not self.is_root(vi)) and (not self.is_hybrid(k)):\n                if vi in rev_map:\n                    raise RuntimeError(\n                        \"Alias list cannot be inverted. \"\n                        + \"Trying to add inverse alias for \"\n                        + vi\n                        + \", which is an alias of \"\n                        + k\n                        + \", but reversed map already has it\"\n                    )\n                rev_map[vi] = k\n    self.alias_map_inv = rev_map\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.PangoLikeNomenclature.is_alias_map_hybrid","title":"<code>is_alias_map_hybrid(alias_value)</code>","text":"<p>Is this lineage a hybrid according to the alias map?</p> <p>Checks whether a value (rather than a key) from an alias map indicates a taxon has hybrid ancestry by checking if it is a container.</p> <p>Parameters:</p> <ul> <li> <code>alias_value</code>               (<code>the value (as opposed to the key) for some taxon in</code>)           \u2013            <p>self.alias_map, i.e., self.alias_map[] <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the alias map indicates this is a hybrid.</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def is_alias_map_hybrid(self, alias_value: Any) -&gt; bool:\n    \"\"\"\n    Is this lineage a hybrid according to the alias map?\n\n    Checks whether a value (rather than a key) from an alias map indicates\n    a taxon has hybrid ancestry by checking if it is a container.\n\n    Parameters\n    ----------\n    alias_value : the value (as opposed to the key) for some taxon in\n        self.alias_map, i.e., self.alias_map[&lt;some key&gt;]\n\n    Returns\n    -------\n    bool\n        True if the alias map indicates this is a hybrid.\n    \"\"\"\n    for t in self.alias_map_hybrid:\n        if isinstance(alias_value, t):\n            return True\n    return False\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.PangoLikeNomenclature.is_special","title":"<code>is_special(name)</code>  <code>abstractmethod</code>","text":"<p>Is this a recognized special-purpose ancestor?</p> <p>Special-purpose ancestors are allowed to be used with 0 sublevels.</p> <p>Under the Pango nomenclature, direct root descendants and recombinants are special-purpose ancestors. Thus for Pango SARS-CoV-2, a special lineage is A, B, or any recombinant such as XBB (but not a descendant, such as XBB.1).</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>A taxon's name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if this taxon is a special taxon.</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>@abstractmethod\ndef is_special(self, name: str) -&gt; bool:\n    \"\"\"\n    Is this a recognized special-purpose ancestor?\n\n    Special-purpose ancestors are allowed to be used with 0 sublevels.\n\n    Under the Pango nomenclature, direct root descendants and recombinants\n    are special-purpose ancestors. Thus for Pango SARS-CoV-2, a special\n    lineage is A, B, or any recombinant such as XBB (but not a descendant,\n    such as XBB.1).\n\n    Parameters\n    ----------\n    name : str\n        A taxon's name.\n\n    Returns\n    -------\n    bool\n        True if this taxon is a special taxon.\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.PangoLikeNomenclature.is_valid_alias","title":"<code>is_valid_alias(alias)</code>","text":"<p>Does this string specify a valid shortcut/alias for a taxon's history?</p> <p>A valid alias should contain only characters allowed in the aliasing portion of the name, possibly with separators if the alias is cumulative.</p> <p>Parameters:</p> <ul> <li> <code>alias</code>               (<code>str</code>)           \u2013            <p>String to be checked for validity as alias.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if this is a valid alias.</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def is_valid_alias(self, alias: str) -&gt; bool:\n    \"\"\"\n    Does this string specify a valid shortcut/alias for a taxon's history?\n\n    A valid alias should contain only characters allowed in the aliasing\n    portion of the name, possibly with separators if the alias is\n    cumulative.\n\n    Parameters\n    ----------\n    alias : str\n        String to be checked for validity as alias.\n\n    Returns\n    -------\n    bool\n        True if this is a valid alias.\n    \"\"\"\n    if self.cumulative_alias:\n        return all([set(a) &lt; self.charsets[0] for a in self.split(alias)])\n    else:\n        return set(alias) &lt; self.charsets[0]\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.PangoLikeNomenclature.join","title":"<code>join(comp)</code>","text":"<p>Join list of component levels into name.</p> <p>The inverse of self.split(name), such that self.join(self.split(name)) == name.</p> <p>Parameters:</p> <ul> <li> <code>comp</code>               (<code>Sequence[str]</code>)           \u2013            <p>Components of a taxon's name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The name a a single string.</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def join(self, comp: Sequence[str]) -&gt; str:\n    \"\"\"\n    Join list of component levels into name.\n\n    The inverse of self.split(name), such that\n    self.join(self.split(name)) == name.\n\n    Parameters\n    ----------\n    comp : Sequence[str]\n        Components of a taxon's name.\n\n    Returns\n    -------\n    str\n        The name a a single string.\n    \"\"\"\n    return self.sep.join(comp)\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.PangoLikeNomenclature.longer_name","title":"<code>longer_name(name)</code>","text":"<p>Get non-aliased form of an aliased name.</p> <p>A long-form name stops at the most recent hybridization event in a taxon's ancestry if there is such an event, otherwise at the special root descendent taxa.</p> <p>For example, the Pango SARS-CoV-2 taxon JN.1.11 would become B.1.1.529.2.86.1.1.11.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>A taxon's name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The taxon's name in the longest form of history.</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def longer_name(self, name: str) -&gt; str:\n    \"\"\"\n    Get non-aliased form of an aliased name.\n\n    A long-form name stops at the most recent hybridization event in a\n    taxon's ancestry if there is such an event, otherwise at the special\n    root descendent taxa.\n\n    For example, the Pango SARS-CoV-2 taxon JN.1.11 would become\n    B.1.1.529.2.86.1.1.11.\n\n    Parameters\n    ----------\n    name : str\n        A taxon's name.\n\n    Returns\n    -------\n    str\n        The taxon's name in the longest form of history.\n    \"\"\"\n    if not self.alias_map:\n        raise RuntimeError(\n            \"Cannot construct long form of name without an alias list.\"\n        )\n    if self.is_root(name):\n        return name\n    alias_levels = list(self.partition_name(name))\n    next_alias = self.alias_map[alias_levels[0][-1]]\n    while not self.is_root(next_alias) and (\n        not self.is_hybrid(alias_levels[0][-1])\n    ):\n        parts = self.partition_name(next_alias)\n        alias_levels[0] = parts[0]\n        alias_levels[1] = [*parts[1], *alias_levels[1]]\n        next_alias = self.alias_map[parts[0][-1]]\n    return self.unpartition_name(alias_levels)\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.PangoLikeNomenclature.next_shorter_alias","title":"<code>next_shorter_alias(name, depth)</code>","text":"<p>Get the next shortest name available to a taxon.</p> <p>This removes one \"layer\" of self.max_sublevels from a name. For example, the Pango SARS-CoV-2 lineage B.1.1.529.2.86.1.1.11 would become BA.2.86.1.1.11 because BA is an alias for B.1.1.529.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>A expanded taxon name to be contracted</p> </li> <li> <code>depth</code>               (<code>int</code>)           \u2013            <p>How many levels of aliasing deep is this name? Starting at 1 for longest (fully de-aliased) name and increasing as the name gets shorter.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The taxon's name with one fewer levels of aliasing.</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def next_shorter_alias(self, name: str, depth: int) -&gt; str:\n    \"\"\"\n    Get the next shortest name available to a taxon.\n\n    This removes one \"layer\" of self.max_sublevels from a name. For\n    example, the Pango SARS-CoV-2 lineage B.1.1.529.2.86.1.1.11 would\n    become BA.2.86.1.1.11 because BA is an alias for B.1.1.529.\n\n    Parameters\n    ----------\n    name : str\n        A expanded taxon name to be contracted\n    depth : int\n        How many levels of aliasing deep is this name? Starting at 1 for\n        longest (fully de-aliased) name and increasing as the name gets\n        shorter.\n\n    Returns\n    -------\n    str\n        The taxon's name with one fewer levels of aliasing.\n    \"\"\"\n\n    parts = self.partition_name(name)\n    n = self.max_sublevels * depth\n    alias = None\n    for k, v in self.alias_map_inv.items():\n        kl = self.partition_name(k)\n        if (\n            kl[1] == parts[1]\n            or self.partition_name(self.longer_name(k))[1][:n]\n            == self.partition_name(self.longer_name(name))[1][:n]\n        ):\n            alias = v\n            break\n    if not alias:\n        raise RuntimeError(\"Cannot find shorter alias for \" + name)\n    return alias\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.PangoLikeNomenclature.num_sublevels","title":"<code>num_sublevels(name)</code>","text":"<p>How many sublevels does this name contain?</p> <p>For a Pango SARS-CoV-2 example, the names XBB, XBB.1, XBB.1.5, and XBB.1.5.39 contain 0, 1, 2, and 3 sublevels respectively.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The taxon's name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The number of sublevels the name contains.</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def num_sublevels(self, name: str) -&gt; int:\n    \"\"\"\n    How many sublevels does this name contain?\n\n    For a Pango SARS-CoV-2 example, the names XBB, XBB.1, XBB.1.5, and\n    XBB.1.5.39 contain 0, 1, 2, and 3 sublevels respectively.\n\n    Parameters\n    ----------\n    name : str\n        The taxon's name.\n\n    Returns\n    -------\n    int\n        The number of sublevels the name contains.\n    \"\"\"\n    return len(self.partition_name(name)[1])\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.PangoLikeNomenclature.partition_name","title":"<code>partition_name(name)</code>","text":"<p>Splits name into alias and sublevels, each as a sequence of components</p> <p>This function assumes that the name is ordered alias, sublevels, and does not check correctness.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The taxon's name to be partitioned.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Sequence[Sequence[str]]</code>           \u2013            <p>First element is Sequence of components in the aliasing portion of the taxon's name, second element is Sequence of sublevels.</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def partition_name(self, name: str) -&gt; Sequence[Sequence[str]]:\n    \"\"\"\n    Splits name into alias and sublevels, each as a sequence of components\n\n    This function assumes that the name is ordered alias, sublevels, and does not check correctness.\n\n    Parameters\n    ----------\n    name : str\n        The taxon's name to be partitioned.\n\n    Returns\n    -------\n    Sequence[Sequence[str]]\n        First element is Sequence of components in the aliasing portion of\n        the taxon's name, second element is Sequence of sublevels.\n    \"\"\"\n    comp = self.split(name)\n    if not self.cumulative_alias:\n        alias = [] if len(comp) == 0 else [comp[0]]\n        sublevels = [] if len(comp) &lt; 2 else comp[1:]\n        return [alias, sublevels]\n\n    if not (set(comp[-1]) &lt; self.charsets[1]):\n        return [comp, []]\n    if not (set(comp[0]) &lt; self.charsets[0]):\n        return [[], comp]\n    n = 1\n    while set(comp[-n]) &lt; self.charsets[1]:\n        n += 1\n\n    alias = [comp[0]] if n == len(comp) else comp[: (len(comp) - n + 1)]\n    sublevels = [comp[-1]] if n == 1 else comp[(len(comp) - n + 1) :]\n    return [alias, sublevels]\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.PangoLikeNomenclature.sanitize_map","title":"<code>sanitize_map()</code>","text":"<p>Drop ambiguity markers and check all names are valid.</p> <p>For the purposes of determining ancestry, an unknown sublineage is     effectively just its ancestor, and we treat it as such.</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>Modifies self.alias_map in-place</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def sanitize_map(self) -&gt; None:\n    \"\"\"\n    Drop ambiguity markers and check all names are valid.\n\n    For the purposes of determining ancestry, an unknown sublineage is\n        effectively just its ancestor, and we treat it as such.\n\n    Returns\n    -------\n    None\n        Modifies self.alias_map in-place\n    \"\"\"\n    if not self.alias_map:\n        raise RuntimeError(\n            \"Missing self.alias_map when trying to sanitize.\"\n        )\n\n    for k, v in self.alias_map.items():\n        if not self.is_valid_alias(k):\n            raise RuntimeError(\n                \"Found invalid taxon as key in alias list: \" + k\n            )\n        if self.is_ambiguous(k):\n            raise RuntimeError(\n                \"Found ambiguous taxon as key in alias list: \" + k\n            )\n        if not self.is_alias_map_hybrid(v):\n            if self.is_root(v):\n                if not self.is_special(k):\n                    raise RuntimeError(\n                        'Found alias for root in taxon not listed as special: \"'\n                        + k\n                        + '\"'\n                    )\n            else:\n                v = [v]\n        for i in range(len(v)):\n            if self.is_ambiguous(v[i]):\n                v[i] = v[i][:-1]\n            if not self.is_valid_name(v[i], max_sublevels=integer_inf):\n                raise RuntimeError(\n                    'Found invalid taxon as value in alias list: \"'\n                    + v[i]\n                    + '\" (for key \"'\n                    + k\n                    + '\")'\n                )\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.PangoLikeNomenclature.shorter_name","title":"<code>shorter_name(name)</code>","text":"<p>Get shortest form of a maximally-long name using aliases</p> <p>For example, the SARS-CoV-2 Pango name B.1.1.529.2.86.1.1.11.1.3 will be made into KP.3, and B.1.1.529.2.86.1.1.11.1 will be made into JN.1.11.1. Both of these are the shortest-possible valid forms of the names, having neither too many nor too few sublevels.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The taxon's name to be shortened.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Shortest valid form of the name for this taxon.</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def shorter_name(self, name: str) -&gt; str:\n    \"\"\"\n    Get shortest form of a maximally-long name using aliases\n\n    For example, the SARS-CoV-2 Pango name B.1.1.529.2.86.1.1.11.1.3 will\n    be made into KP.3, and B.1.1.529.2.86.1.1.11.1 will be made into\n    JN.1.11.1. Both of these are the shortest-possible valid forms of the\n    names, having neither too many nor too few sublevels.\n\n    Parameters\n    ----------\n    name : str\n        The taxon's name to be shortened.\n\n    Returns\n    -------\n    str\n        Shortest valid form of the name for this taxon.\n    \"\"\"\n    if not self.alias_map:\n        raise RuntimeError(\n            \"Cannot get shorter name without an alias list.\"\n        )\n    comp = list(self.partition_name(name))\n    lvl = 1\n    while len(comp[1]) &gt; self.max_sublevels:\n        alias = self.next_shorter_alias(self.unpartition_name(comp), lvl)\n        comp[0] = [alias]\n        comp[1] = comp[1][3:]\n        lvl += 1\n    return self.unpartition_name(comp)\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.PangoLikeNomenclature.split","title":"<code>split(name)</code>","text":"<p>Split name into component levels</p> <p>The inverse of self.join(name), such that self.split(self.join(components)) == components.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name a a single string.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Sequence[str]</code>           \u2013            <p>Components of a taxon's name.</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def split(self, name: str) -&gt; Sequence[str]:\n    \"\"\"\n    Split name into component levels\n\n    The inverse of self.join(name), such that\n    self.split(self.join(components)) == components.\n\n    Parameters\n    ----------\n    name : str\n        The name a a single string.\n\n    Returns\n    -------\n    Sequence[str]\n        Components of a taxon's name.\n    \"\"\"\n    return name.split(self.sep)\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.PangoLikeNomenclature.unpartition_name","title":"<code>unpartition_name(components)</code>","text":"<p>Undoes partition_name</p> <p>Parameters:</p> <ul> <li> <code>components</code>               (<code>Sequence[Sequence[str]]</code>)           \u2013            <p>First element is Sequence of components in the aliasing portion of the taxon's name, second element is Sequence of sublevels.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The taxon's name as a single string.</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def unpartition_name(self, components: Sequence[Sequence[str]]) -&gt; str:\n    \"\"\"\n    Undoes partition_name\n\n    Parameters\n    ----------\n    components : Sequence[Sequence[str]]\n        First element is Sequence of components in the aliasing portion of\n        the taxon's name, second element is Sequence of sublevels.\n\n    Returns\n    -------\n    str\n        The taxon's name as a single string.\n    \"\"\"\n    return self.join([*components[0], *components[1]])\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.PangoNomenclature","title":"<code>PangoNomenclature</code>","text":"<p>               Bases: <code>PangoLikeNomenclature</code>, <code>HistoryAwareNomenclature</code></p> <p>Pango nomenclature in the general sense, absent SARS-CoV-2- or mpox-specific features.</p> <p>Nomenclatures for specific systems to which Pango is applied are initialized from this class by filling in the system-specific details and providing a location for the alias map. See init for details.</p> <p>See: https://doi.org/10.1038/s41564-020-0770-5</p> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>class PangoNomenclature(PangoLikeNomenclature, HistoryAwareNomenclature):\n    \"\"\"\n    Pango nomenclature in the general sense, absent SARS-CoV-2- or mpox-specific features.\n\n    Nomenclatures for specific systems to which Pango is applied are initialized from\n    this class by filling in the system-specific details and providing a location for\n    the alias map. See __init__ for details.\n\n    See: https://doi.org/10.1038/s41564-020-0770-5\n    \"\"\"\n\n    def __init__(\n        self,\n        alias_map_hybrid: Collection[type],\n        max_sublevels: int,\n        special: Container,\n        system: str,\n        repo: str,\n        local_alias_path: Optional[str] = None,\n        repo_alias_path: Optional[str] = None,\n        repo_versioning_path: Optional[str] = None,\n        versioning_extractor: Optional[\n            Callable[[str], Collection[str]]\n        ] = None,\n    ):\n        \"\"\"\n        Initialization of PangoNomenclature objects.\n\n        Parameters\n        ----------\n        alias_map_hybrid : Collection[type]\n            Container type(s) used in alias map when hybrid ancestry is indicated.\n        max_sublevels : int\n            Defines maximum number of sublevels before aliasing must be done, 3 for\n            Pango SARS-CoV-2.\n        system : str\n            The nomenclature's name is taken to be f\"PangoNomenclature({system})\", e.g.\n            \"PangoNomenclature(SARS-CoV-2)\".\n        repo : str\n            The username/repository pair for the GitHub repository hosting nomenclature\n            information.\n        local_alias_path: Optional[str]\n            A filepath to a local json providing the alias map. Must provide either\n            this or url_alias_json.\n        repo_alias_path: Optional[str]\n            Path to the alias json in the GitHub repository. Must provide either this\n            or local_alias_path.\n        repo_versioning_path: Optional[str]\n            Path to file in repo which contains the list of recognized names. Allows\n            instantiated class to provide a NomenclatureVersioner on request.\n        versioning_extractor: Optional[Callable[[str], Collection[str]]]\n            A function that processes the read file read from repo_versioning_path\n            and returns the known taxa.\n        \"\"\"\n        super().__init__(\n            alias_map_hybrid=alias_map_hybrid,\n            charsets=[set(string.ascii_uppercase), set(string.digits)],\n            cumulative_alias=False,\n            max_sublevels=max_sublevels,\n            root=\"\",\n            sep=r\".\",\n            special=special,\n            name=f\"PangoNomenclature({system})\",\n        )\n        self.ambiguity = r\"*\"\n        self.repo = repo\n        self.local_alias_path = local_alias_path\n        self.repo_alias_path = repo_alias_path\n        self.repo_versioning_path = repo_versioning_path\n        self.versioning_extractor = versioning_extractor\n\n        if (self.local_alias_path is None) and (self.repo_alias_path is None):\n            raise ValueError(\n                \"Must provide either a local or remote filepath to the alias json.\"\n            )\n\n    ##############################\n    # Superclass implementations #\n    ##############################\n    def get_versioner(self, as_of: datetime.date):\n        if self.repo_versioning_path is None:\n            raise RuntimeError(\n                \"Cannot get versioner without path to file containing previously known taxa.\"\n            )\n        if self.versioning_extractor is None:\n            raise RuntimeError(\n                \"Cannot get versioner without function to extract taxa from file.\"\n            )\n        versioner = NomenclatureVersioner.from_gh_file(\n            repo=self.repo,\n            file_path=self.repo_versioning_path,\n            as_of=as_of,\n            extractor=self.versioning_extractor,\n        )\n        # Check we have only valid names\n        self.validate(versioner.names)\n        return versioner\n\n    def is_ambiguous(self, name: str) -&gt; bool:\n        \"\"\"\n        Does this name specify an ambiguous taxon?\n\n        Pango taxa are ambiguous if the name ends in *, such that JN.1* means\n        some unknown or unspecified sublineage of JN.1.\n\n        Parameters\n        ----------\n        name : str\n            The name of the taxon\n\n        Returns\n        -------\n        bool\n            True if the name is ambiguous.\n        \"\"\"\n        if self.is_root(name):\n            return False\n        elif str(name)[-1] == self.ambiguity:\n            return True\n        else:\n            return False\n\n    def is_hybrid(self, name: str) -&gt; bool:\n        \"\"\"\n        Does this name specify a hybrid taxon?\n\n        Hybrids are recombinants, and recombinant names start with X:\n        https://virological.org/t/pango-lineage-nomenclature-provisional-rules-for-naming-recombinant-lineages/657\n\n        Parameters\n        ----------\n        name : str\n            The name of the taxon\n\n        Returns\n        -------\n        bool\n            True if the name is a hybrid.\n        \"\"\"\n        if self.is_root(name):\n            return False\n        elif name[0] == \"X\":\n            return True\n        else:\n            return False\n\n    def is_special(self, name: str) -&gt; bool:\n        return name in self.special or (\n            self.is_hybrid(name) and self.num_sublevels(name) == 0\n        )\n\n    def setup_alias_map(self, as_of: Optional[datetime.date] = None) -&gt; None:\n        \"\"\"\n        Sets up the alias and reverse alias maps.\n\n        The alias map will be retrieved preferentially from local using self.local_alias_path\n        if it exists, otherwise it will be retrieved from GitHub using self.repo_alias_path and\n        self.repo. If neither are specified, a RuntimeError is raised.\n\n        Can retrieve older committed versions of the alias json from GitHub, but this\n        must be used with care. Older aliasing lists know nothing of newer names\n        and both PangoNomenclature.longer_name() and PangoNomenclature.shorter_name()\n        can fail at runtime!\n\n        Raw alias maps for Pango nomenclatures are (remote or local) json files\n        which provide either:\n            1. The long-form names to replace an alias\n            2. The parents of a recombinant\n\n        Neither of these need to be in the absolute longest form to work, so that,\n        for example, either \"JN\": \"B.1.1.529.2.86.1\" or \"JN\": \"BA.2.86.1\" would be\n        valid.\n\n        Parameters\n        -------\n        as_of: datetime.date\n            The date for which to retrieve the alias list when not reading from local.\n            None (default) for most current.\n\n        Returns\n        -------\n        None\n            Reads the alias map and stores it in self.alias_map, then calls\n            self.sanitize_map() and self.invert_map().\n        \"\"\"\n        # Should we be thinking about encoding and/or defensive measures?\n        if self.local_alias_path:\n            alias_file = open(self.local_alias_path)\n            alias = json.load(alias_file)\n            alias_file.close()\n            self.alias_map = dict(alias)\n        elif self.repo_alias_path:\n            alias_str = get_gh_file_contents_as_of(\n                self.repo, self.repo_alias_path, as_of\n            )\n            self.alias_map = json.loads(alias_str)\n        else:\n            raise RuntimeError(\n                \"Must provide either a local or remote filepath to the alias json.\"\n            )\n\n        self.sanitize_map()\n        self.invert_map()\n\n    ########################\n    # Superclass overrides #\n    ########################\n\n    def is_valid_name(\n        self,\n        name: str,\n        min_sublevels: int = 1,\n        max_sublevels: int | None = None,\n    ) -&gt; bool:\n        \"\"\"\n        Is this name valid in the Pango nomenclature?\n\n        A valid name must have &gt;1 and &lt;= self.max_sublevels sublevels unless\n        it is a special-purpose ancestor such as a recombinant or a directly-\n        named root descendant, in which case they may have 0 sublevels.\n\n        Parameters\n        ----------\n        name : str\n            string specifying name of the taxon\n\n        Returns\n        -------\n        bool\n            True if this is a valid name under the Pango nomenclature.\n        \"\"\"\n        if self.is_root(name) or self.is_special(name) or self.is_hybrid(name):\n            return True\n        return super().is_valid_name(name, min_sublevels, max_sublevels)\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.PangoNomenclature.__init__","title":"<code>__init__(alias_map_hybrid, max_sublevels, special, system, repo, local_alias_path=None, repo_alias_path=None, repo_versioning_path=None, versioning_extractor=None)</code>","text":"<p>Initialization of PangoNomenclature objects.</p> <p>Parameters:</p> <ul> <li> <code>alias_map_hybrid</code>               (<code>Collection[type]</code>)           \u2013            <p>Container type(s) used in alias map when hybrid ancestry is indicated.</p> </li> <li> <code>max_sublevels</code>               (<code>int</code>)           \u2013            <p>Defines maximum number of sublevels before aliasing must be done, 3 for Pango SARS-CoV-2.</p> </li> <li> <code>system</code>               (<code>str</code>)           \u2013            <p>The nomenclature's name is taken to be f\"PangoNomenclature({system})\", e.g. \"PangoNomenclature(SARS-CoV-2)\".</p> </li> <li> <code>repo</code>               (<code>str</code>)           \u2013            <p>The username/repository pair for the GitHub repository hosting nomenclature information.</p> </li> <li> <code>local_alias_path</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>A filepath to a local json providing the alias map. Must provide either this or url_alias_json.</p> </li> <li> <code>repo_alias_path</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Path to the alias json in the GitHub repository. Must provide either this or local_alias_path.</p> </li> <li> <code>repo_versioning_path</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Path to file in repo which contains the list of recognized names. Allows instantiated class to provide a NomenclatureVersioner on request.</p> </li> <li> <code>versioning_extractor</code>               (<code>Optional[Callable[[str], Collection[str]]]</code>, default:                   <code>None</code> )           \u2013            <p>A function that processes the read file read from repo_versioning_path and returns the known taxa.</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def __init__(\n    self,\n    alias_map_hybrid: Collection[type],\n    max_sublevels: int,\n    special: Container,\n    system: str,\n    repo: str,\n    local_alias_path: Optional[str] = None,\n    repo_alias_path: Optional[str] = None,\n    repo_versioning_path: Optional[str] = None,\n    versioning_extractor: Optional[\n        Callable[[str], Collection[str]]\n    ] = None,\n):\n    \"\"\"\n    Initialization of PangoNomenclature objects.\n\n    Parameters\n    ----------\n    alias_map_hybrid : Collection[type]\n        Container type(s) used in alias map when hybrid ancestry is indicated.\n    max_sublevels : int\n        Defines maximum number of sublevels before aliasing must be done, 3 for\n        Pango SARS-CoV-2.\n    system : str\n        The nomenclature's name is taken to be f\"PangoNomenclature({system})\", e.g.\n        \"PangoNomenclature(SARS-CoV-2)\".\n    repo : str\n        The username/repository pair for the GitHub repository hosting nomenclature\n        information.\n    local_alias_path: Optional[str]\n        A filepath to a local json providing the alias map. Must provide either\n        this or url_alias_json.\n    repo_alias_path: Optional[str]\n        Path to the alias json in the GitHub repository. Must provide either this\n        or local_alias_path.\n    repo_versioning_path: Optional[str]\n        Path to file in repo which contains the list of recognized names. Allows\n        instantiated class to provide a NomenclatureVersioner on request.\n    versioning_extractor: Optional[Callable[[str], Collection[str]]]\n        A function that processes the read file read from repo_versioning_path\n        and returns the known taxa.\n    \"\"\"\n    super().__init__(\n        alias_map_hybrid=alias_map_hybrid,\n        charsets=[set(string.ascii_uppercase), set(string.digits)],\n        cumulative_alias=False,\n        max_sublevels=max_sublevels,\n        root=\"\",\n        sep=r\".\",\n        special=special,\n        name=f\"PangoNomenclature({system})\",\n    )\n    self.ambiguity = r\"*\"\n    self.repo = repo\n    self.local_alias_path = local_alias_path\n    self.repo_alias_path = repo_alias_path\n    self.repo_versioning_path = repo_versioning_path\n    self.versioning_extractor = versioning_extractor\n\n    if (self.local_alias_path is None) and (self.repo_alias_path is None):\n        raise ValueError(\n            \"Must provide either a local or remote filepath to the alias json.\"\n        )\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.PangoNomenclature.is_ambiguous","title":"<code>is_ambiguous(name)</code>","text":"<p>Does this name specify an ambiguous taxon?</p> <p>Pango taxa are ambiguous if the name ends in , such that JN.1 means some unknown or unspecified sublineage of JN.1.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the taxon</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the name is ambiguous.</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def is_ambiguous(self, name: str) -&gt; bool:\n    \"\"\"\n    Does this name specify an ambiguous taxon?\n\n    Pango taxa are ambiguous if the name ends in *, such that JN.1* means\n    some unknown or unspecified sublineage of JN.1.\n\n    Parameters\n    ----------\n    name : str\n        The name of the taxon\n\n    Returns\n    -------\n    bool\n        True if the name is ambiguous.\n    \"\"\"\n    if self.is_root(name):\n        return False\n    elif str(name)[-1] == self.ambiguity:\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.PangoNomenclature.is_hybrid","title":"<code>is_hybrid(name)</code>","text":"<p>Does this name specify a hybrid taxon?</p> <p>Hybrids are recombinants, and recombinant names start with X: https://virological.org/t/pango-lineage-nomenclature-provisional-rules-for-naming-recombinant-lineages/657</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name of the taxon</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the name is a hybrid.</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def is_hybrid(self, name: str) -&gt; bool:\n    \"\"\"\n    Does this name specify a hybrid taxon?\n\n    Hybrids are recombinants, and recombinant names start with X:\n    https://virological.org/t/pango-lineage-nomenclature-provisional-rules-for-naming-recombinant-lineages/657\n\n    Parameters\n    ----------\n    name : str\n        The name of the taxon\n\n    Returns\n    -------\n    bool\n        True if the name is a hybrid.\n    \"\"\"\n    if self.is_root(name):\n        return False\n    elif name[0] == \"X\":\n        return True\n    else:\n        return False\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.PangoNomenclature.is_valid_name","title":"<code>is_valid_name(name, min_sublevels=1, max_sublevels=None)</code>","text":"<p>Is this name valid in the Pango nomenclature?</p> <p>A valid name must have &gt;1 and &lt;= self.max_sublevels sublevels unless it is a special-purpose ancestor such as a recombinant or a directly- named root descendant, in which case they may have 0 sublevels.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>string specifying name of the taxon</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if this is a valid name under the Pango nomenclature.</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def is_valid_name(\n    self,\n    name: str,\n    min_sublevels: int = 1,\n    max_sublevels: int | None = None,\n) -&gt; bool:\n    \"\"\"\n    Is this name valid in the Pango nomenclature?\n\n    A valid name must have &gt;1 and &lt;= self.max_sublevels sublevels unless\n    it is a special-purpose ancestor such as a recombinant or a directly-\n    named root descendant, in which case they may have 0 sublevels.\n\n    Parameters\n    ----------\n    name : str\n        string specifying name of the taxon\n\n    Returns\n    -------\n    bool\n        True if this is a valid name under the Pango nomenclature.\n    \"\"\"\n    if self.is_root(name) or self.is_special(name) or self.is_hybrid(name):\n        return True\n    return super().is_valid_name(name, min_sublevels, max_sublevels)\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.PangoNomenclature.setup_alias_map","title":"<code>setup_alias_map(as_of=None)</code>","text":"<p>Sets up the alias and reverse alias maps.</p> <p>The alias map will be retrieved preferentially from local using self.local_alias_path if it exists, otherwise it will be retrieved from GitHub using self.repo_alias_path and self.repo. If neither are specified, a RuntimeError is raised.</p> <p>Can retrieve older committed versions of the alias json from GitHub, but this must be used with care. Older aliasing lists know nothing of newer names and both PangoNomenclature.longer_name() and PangoNomenclature.shorter_name() can fail at runtime!</p> <p>Raw alias maps for Pango nomenclatures are (remote or local) json files which provide either:     1. The long-form names to replace an alias     2. The parents of a recombinant</p> <p>Neither of these need to be in the absolute longest form to work, so that, for example, either \"JN\": \"B.1.1.529.2.86.1\" or \"JN\": \"BA.2.86.1\" would be valid.</p> <p>Parameters:</p> <ul> <li> <code>as_of</code>               (<code>Optional[date]</code>, default:                   <code>None</code> )           \u2013            <p>The date for which to retrieve the alias list when not reading from local. None (default) for most current.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>Reads the alias map and stores it in self.alias_map, then calls self.sanitize_map() and self.invert_map().</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def setup_alias_map(self, as_of: Optional[datetime.date] = None) -&gt; None:\n    \"\"\"\n    Sets up the alias and reverse alias maps.\n\n    The alias map will be retrieved preferentially from local using self.local_alias_path\n    if it exists, otherwise it will be retrieved from GitHub using self.repo_alias_path and\n    self.repo. If neither are specified, a RuntimeError is raised.\n\n    Can retrieve older committed versions of the alias json from GitHub, but this\n    must be used with care. Older aliasing lists know nothing of newer names\n    and both PangoNomenclature.longer_name() and PangoNomenclature.shorter_name()\n    can fail at runtime!\n\n    Raw alias maps for Pango nomenclatures are (remote or local) json files\n    which provide either:\n        1. The long-form names to replace an alias\n        2. The parents of a recombinant\n\n    Neither of these need to be in the absolute longest form to work, so that,\n    for example, either \"JN\": \"B.1.1.529.2.86.1\" or \"JN\": \"BA.2.86.1\" would be\n    valid.\n\n    Parameters\n    -------\n    as_of: datetime.date\n        The date for which to retrieve the alias list when not reading from local.\n        None (default) for most current.\n\n    Returns\n    -------\n    None\n        Reads the alias map and stores it in self.alias_map, then calls\n        self.sanitize_map() and self.invert_map().\n    \"\"\"\n    # Should we be thinking about encoding and/or defensive measures?\n    if self.local_alias_path:\n        alias_file = open(self.local_alias_path)\n        alias = json.load(alias_file)\n        alias_file.close()\n        self.alias_map = dict(alias)\n    elif self.repo_alias_path:\n        alias_str = get_gh_file_contents_as_of(\n            self.repo, self.repo_alias_path, as_of\n        )\n        self.alias_map = json.loads(alias_str)\n    else:\n        raise RuntimeError(\n            \"Must provide either a local or remote filepath to the alias json.\"\n        )\n\n    self.sanitize_map()\n    self.invert_map()\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.TreeProvider","title":"<code>TreeProvider</code>","text":"<p>               Bases: <code>Nomenclature</code></p> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>class TreeProvider(Nomenclature):\n    @abstractmethod\n    def taxonomy_tree(\n        self,\n        taxa: Sequence[Taxon],\n        insert_tips: bool,\n        name_cleanup_fun: Optional[Callable[[str], str]] = None,\n        warn: bool = True,\n    ) -&gt; dendropy.Tree:\n        \"\"\"\n        Makes a taxonomy tree for a set of taxa.\n\n        A taxonomy tree is the core object of a PhylogeneticTaxonomyScheme,\n        being a phylogenetic representation of the relationships between\n        all taxa. It takes the form of a dendropy.Tree object where every\n        node has a label.\n\n        Parameters\n        ----------\n        taxa : Sequence[Taxon]\n            We will build the tree of these taxa.\n        insert_tips : boolean\n            If True, where a Taxon in the provided taxa is an internal node,\n            a tip is added to represent any paraphyletic observations of this\n            taxon using add_paraphyletic_tips().\n        name_cleanup_fun : Optional[Callable]\n            A function applied to all node labels after the tree is\n            constructed, to ensure validity of all names.\n        warn : bool\n            Should we warn the user if any taxa are dropped in the process\n            of making the tree?\n\n        Returns\n        -------\n        dendropy.Tree object with all nodes labeled\n            The taxonomy tree is given by the phylogeny and all nodes are\n            labeled with the taxon they represent. This tree may have nodes\n            with only one descendant.\n        \"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.TreeProvider.taxonomy_tree","title":"<code>taxonomy_tree(taxa, insert_tips, name_cleanup_fun=None, warn=True)</code>  <code>abstractmethod</code>","text":"<p>Makes a taxonomy tree for a set of taxa.</p> <p>A taxonomy tree is the core object of a PhylogeneticTaxonomyScheme, being a phylogenetic representation of the relationships between all taxa. It takes the form of a dendropy.Tree object where every node has a label.</p> <p>Parameters:</p> <ul> <li> <code>taxa</code>               (<code>Sequence[Taxon]</code>)           \u2013            <p>We will build the tree of these taxa.</p> </li> <li> <code>insert_tips</code>               (<code>boolean</code>)           \u2013            <p>If True, where a Taxon in the provided taxa is an internal node, a tip is added to represent any paraphyletic observations of this taxon using add_paraphyletic_tips().</p> </li> <li> <code>name_cleanup_fun</code>               (<code>Optional[Callable]</code>, default:                   <code>None</code> )           \u2013            <p>A function applied to all node labels after the tree is constructed, to ensure validity of all names.</p> </li> <li> <code>warn</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Should we warn the user if any taxa are dropped in the process of making the tree?</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dendropy.Tree object with all nodes labeled</code>           \u2013            <p>The taxonomy tree is given by the phylogeny and all nodes are labeled with the taxon they represent. This tree may have nodes with only one descendant.</p> </li> </ul> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>@abstractmethod\ndef taxonomy_tree(\n    self,\n    taxa: Sequence[Taxon],\n    insert_tips: bool,\n    name_cleanup_fun: Optional[Callable[[str], str]] = None,\n    warn: bool = True,\n) -&gt; dendropy.Tree:\n    \"\"\"\n    Makes a taxonomy tree for a set of taxa.\n\n    A taxonomy tree is the core object of a PhylogeneticTaxonomyScheme,\n    being a phylogenetic representation of the relationships between\n    all taxa. It takes the form of a dendropy.Tree object where every\n    node has a label.\n\n    Parameters\n    ----------\n    taxa : Sequence[Taxon]\n        We will build the tree of these taxa.\n    insert_tips : boolean\n        If True, where a Taxon in the provided taxa is an internal node,\n        a tip is added to represent any paraphyletic observations of this\n        taxon using add_paraphyletic_tips().\n    name_cleanup_fun : Optional[Callable]\n        A function applied to all node labels after the tree is\n        constructed, to ensure validity of all names.\n    warn : bool\n        Should we warn the user if any taxa are dropped in the process\n        of making the tree?\n\n    Returns\n    -------\n    dendropy.Tree object with all nodes labeled\n        The taxonomy tree is given by the phylogeny and all nodes are\n        labeled with the taxon they represent. This tree may have nodes\n        with only one descendant.\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.ensure_taxa_known","title":"<code>ensure_taxa_known(func)</code>","text":"<p>A decorator for NextstrainLikeNomenclature that makes sure the master taxon list has been read in from GitHub.</p> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def ensure_taxa_known(func: Callable) -&gt; Callable:\n    \"\"\"\n    A decorator for NextstrainLikeNomenclature that makes sure the master taxon list has been read in from GitHub.\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(self, *args, **kwargs):\n        if not self.taxa:\n            self.populate_taxa()\n        return func(self, *args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"api/#cladecombiner.nomenclature.ensure_tree_known","title":"<code>ensure_tree_known(func)</code>","text":"<p>A decorator for NextstrainLikeNomenclature that makes sure the master tree has been read in from GitHub.</p> Source code in <code>cladecombiner/nomenclature.py</code> <pre><code>def ensure_tree_known(func: Callable) -&gt; Callable:\n    \"\"\"\n    A decorator for NextstrainLikeNomenclature that makes sure the master tree has been read in from GitHub.\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(self, *args, **kwargs):\n        if self.master_tree is None:\n            self.populate_tree()\n        return func(self, *args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"api/#cladecombiner.taxonomy_scheme","title":"<code>cladecombiner.taxonomy_scheme</code>","text":""},{"location":"api/#cladecombiner.taxonomy_scheme.PhylogeneticTaxonomyScheme","title":"<code>PhylogeneticTaxonomyScheme</code>","text":"<p>               Bases: <code>TreelikeTaxonomyScheme</code></p> <p>A TaxonomyScheme powered by a phylogeny.</p> <p>Errors are provoked when a PhylogeneticTaxonomyScheme is queried about taxa that are not in the phylogeny.</p> <p>Internally, a dendropy.Tree object is used to represent the taxonomic relationships.</p> Source code in <code>cladecombiner/taxonomy_scheme.py</code> <pre><code>class PhylogeneticTaxonomyScheme(TreelikeTaxonomyScheme):\n    \"\"\"\n    A TaxonomyScheme powered by a phylogeny.\n\n    Errors are provoked when a PhylogeneticTaxonomyScheme is queried about taxa\n    that are not in the phylogeny.\n\n    Internally, a dendropy.Tree object is used to represent the taxonomic\n    relationships.\n    \"\"\"\n\n    def __init__(self, tree: dendropy.Tree):\n        \"\"\"\n        PhylogeneticTaxonomyScheme constructor\n\n        Parameters\n        ----------\n        tree : dendropy.Tree\n            The phylogeny to be used, internal nodes must be labeled.\n        \"\"\"\n\n        for node in tree.preorder_node_iter():\n            if node.label is None:\n                raise ValueError(\n                    \"TaxonomyTree constructor requires all nodes have labels.\"\n                )\n        self.tree = tree\n        \"The tree describing the relationships between taxa\"\n        self.node_to_taxon: dict[dendropy.Node, Taxon] = {}\n        \"The taxon represented by each node, for ease of access\"\n        self.taxon_to_node: dict[Taxon, dendropy.Node] = {}\n        \"The node representing each taxon, for ease of access\"\n\n        self.map_from_tree()\n\n    ########################\n    # Superclass overrides #\n    #                      #\n    # These change only    #\n    # how methods work,    #\n    # not what they return #\n    ########################\n\n    def ancestors(self, taxon: Taxon) -&gt; Sequence[Taxon]:\n        nodes = self.node_path_to_root(taxon)\n        return [self.node_to_taxon[node] for node in nodes[1:]]\n\n    def children(self, taxon: Taxon) -&gt; Collection[Taxon]:\n        child_nodes = self.taxon_to_node[taxon].child_nodes()\n        children = []\n        if child_nodes:\n            for node in child_nodes:\n                children.append(self.node_to_taxon[node])\n        return children\n\n    def contains(self, focal: Taxon, target: Taxon) -&gt; bool:\n        if focal not in self.taxon_to_node:\n            return False\n        node_x = self.taxon_to_node[focal]\n\n        if target not in self.taxon_to_node:\n            return False\n        node = self.taxon_to_node[target]\n\n        while node is not self.tree.seed_node:\n            if node is node_x:\n                return True\n            node = node.parent_node\n\n        if node is node_x:\n            return True\n\n        return False\n\n    def descendants(self, taxon: Taxon, tip_only: bool) -&gt; Collection[Taxon]:\n        desc = []\n        queue = [self.taxon_to_node[taxon]]\n        while queue:\n            node = queue.pop(0)\n            has_kids = False\n            for child in node.child_node_iter():\n                has_kids = True\n                queue.append(child)\n            if (not tip_only) or (not has_kids):\n                desc.append(self.node_to_taxon[node])\n        if not tip_only:\n            desc = desc[1:]\n        return desc\n\n    def is_root(self, taxon: Taxon) -&gt; bool:\n        return taxon == self.node_to_taxon[self.root()]\n\n    def is_valid_taxon(self, taxon: Taxon) -&gt; bool:\n        return taxon in self.taxon_to_node.keys()\n\n    def mrca(self, taxa: Sequence[Taxon]) -&gt; Taxon:\n        paths = [self.node_path_to_root(taxon) for taxon in taxa]\n        max_idx = max([len(path) for path in paths])\n        idx = 0\n        while idx &lt; max_idx:\n            tax_at_lvl = set([path[-(1 + idx)] for path in paths])\n            if len(tax_at_lvl) == 1:\n                idx += 1\n            else:\n                idx -= 1\n                break\n        if idx &lt; 0:\n            raise RuntimeError(\"Provided taxa do not have MRCA in the tree.\")\n        return self.node_to_taxon[paths[0][-(1 + idx)]]\n\n    def parents(self, taxon: Taxon) -&gt; Taxon | None:\n        node_x = self.taxon_to_node[taxon]\n        if node_x is self.tree.seed_node:\n            return None\n        return self.node_to_taxon[node_x.parent_node]\n\n    #################\n    # Class methods #\n    #################\n\n    def map_from_tree(self) -&gt; None:\n        \"\"\"\n        Make Node&lt;-&gt;Taxon maps\n\n        By using these maps, we can avoid searching the tree repeatedly.\n\n        Returns\n        -------\n        None\n            Modifies self.node_to_taxon and self.taxon_to_node in-place.\n        \"\"\"\n\n        self.node_to_taxon = {}\n        self.taxon_to_node = {}\n        for node in self.tree.preorder_node_iter():\n            assert isinstance(node.is_leaf(), bool)  # Pylance paranoia\n            taxon = Taxon(node.label, is_tip=node.is_leaf())\n            self.node_to_taxon[node] = taxon\n            self.taxon_to_node[taxon] = node\n\n    def node_path_to_root(self, taxon: Taxon) -&gt; Sequence[dendropy.Node]:\n        \"\"\"\n        Get all nodes between given taxon and the root (inclusive of the root and this node)\n\n        Parameters\n        ----------\n        taxon : Taxon\n            The taxon for which we want the path to the root.\n\n        Returns\n        -------\n        Sequence[dendropy.Node]\n            Path of nodes in self.tree from this taxon (inclusive) to the root\n            (inclusive).\n        \"\"\"\n        path = []\n        node = self.taxon_to_node[taxon]\n        while node is not self.tree.seed_node:\n            path.append(node)\n            node = node.parent_node\n        path.append(self.root())\n        return path\n\n    def prune_subtree(self, taxon: Taxon) -&gt; None:\n        \"\"\"\n        Remove subtree corresponding to this taxon and clean up maps\n\n        Parameters\n        ----------\n        taxon : Taxon\n            The taxon which is the base of the subtree to be removed.\n\n        Returns\n        -------\n        None\n            Edits self.tree in-place.\n        \"\"\"\n        node = self.taxon_to_node[taxon]\n        node.parent_node.remove_child(node)\n        self.map_from_tree()\n\n    def root(self) -&gt; dendropy.Node:\n        \"\"\"\n        Typing-safe function to access root, always returns a dendropy.Node.\n\n        Returns\n        -------\n        dendropy.Node\n            The root node of the phylogeny underlying this taxonomy scheme.\n        \"\"\"\n        if not isinstance(self.tree.seed_node, dendropy.Node):\n            raise RuntimeError(\"Malformed tree has no seed_node\")\n        else:\n            return self.tree.seed_node\n</code></pre>"},{"location":"api/#cladecombiner.taxonomy_scheme.PhylogeneticTaxonomyScheme.node_to_taxon","title":"<code>node_to_taxon = {}</code>  <code>instance-attribute</code>","text":"<p>The taxon represented by each node, for ease of access</p>"},{"location":"api/#cladecombiner.taxonomy_scheme.PhylogeneticTaxonomyScheme.taxon_to_node","title":"<code>taxon_to_node = {}</code>  <code>instance-attribute</code>","text":"<p>The node representing each taxon, for ease of access</p>"},{"location":"api/#cladecombiner.taxonomy_scheme.PhylogeneticTaxonomyScheme.tree","title":"<code>tree = tree</code>  <code>instance-attribute</code>","text":"<p>The tree describing the relationships between taxa</p>"},{"location":"api/#cladecombiner.taxonomy_scheme.PhylogeneticTaxonomyScheme.__init__","title":"<code>__init__(tree)</code>","text":"<p>PhylogeneticTaxonomyScheme constructor</p> <p>Parameters:</p> <ul> <li> <code>tree</code>               (<code>Tree</code>)           \u2013            <p>The phylogeny to be used, internal nodes must be labeled.</p> </li> </ul> Source code in <code>cladecombiner/taxonomy_scheme.py</code> <pre><code>def __init__(self, tree: dendropy.Tree):\n    \"\"\"\n    PhylogeneticTaxonomyScheme constructor\n\n    Parameters\n    ----------\n    tree : dendropy.Tree\n        The phylogeny to be used, internal nodes must be labeled.\n    \"\"\"\n\n    for node in tree.preorder_node_iter():\n        if node.label is None:\n            raise ValueError(\n                \"TaxonomyTree constructor requires all nodes have labels.\"\n            )\n    self.tree = tree\n    \"The tree describing the relationships between taxa\"\n    self.node_to_taxon: dict[dendropy.Node, Taxon] = {}\n    \"The taxon represented by each node, for ease of access\"\n    self.taxon_to_node: dict[Taxon, dendropy.Node] = {}\n    \"The node representing each taxon, for ease of access\"\n\n    self.map_from_tree()\n</code></pre>"},{"location":"api/#cladecombiner.taxonomy_scheme.PhylogeneticTaxonomyScheme.map_from_tree","title":"<code>map_from_tree()</code>","text":"<p>Make Node&lt;-&gt;Taxon maps</p> <p>By using these maps, we can avoid searching the tree repeatedly.</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>Modifies self.node_to_taxon and self.taxon_to_node in-place.</p> </li> </ul> Source code in <code>cladecombiner/taxonomy_scheme.py</code> <pre><code>def map_from_tree(self) -&gt; None:\n    \"\"\"\n    Make Node&lt;-&gt;Taxon maps\n\n    By using these maps, we can avoid searching the tree repeatedly.\n\n    Returns\n    -------\n    None\n        Modifies self.node_to_taxon and self.taxon_to_node in-place.\n    \"\"\"\n\n    self.node_to_taxon = {}\n    self.taxon_to_node = {}\n    for node in self.tree.preorder_node_iter():\n        assert isinstance(node.is_leaf(), bool)  # Pylance paranoia\n        taxon = Taxon(node.label, is_tip=node.is_leaf())\n        self.node_to_taxon[node] = taxon\n        self.taxon_to_node[taxon] = node\n</code></pre>"},{"location":"api/#cladecombiner.taxonomy_scheme.PhylogeneticTaxonomyScheme.node_path_to_root","title":"<code>node_path_to_root(taxon)</code>","text":"<p>Get all nodes between given taxon and the root (inclusive of the root and this node)</p> <p>Parameters:</p> <ul> <li> <code>taxon</code>               (<code>Taxon</code>)           \u2013            <p>The taxon for which we want the path to the root.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Sequence[Node]</code>           \u2013            <p>Path of nodes in self.tree from this taxon (inclusive) to the root (inclusive).</p> </li> </ul> Source code in <code>cladecombiner/taxonomy_scheme.py</code> <pre><code>def node_path_to_root(self, taxon: Taxon) -&gt; Sequence[dendropy.Node]:\n    \"\"\"\n    Get all nodes between given taxon and the root (inclusive of the root and this node)\n\n    Parameters\n    ----------\n    taxon : Taxon\n        The taxon for which we want the path to the root.\n\n    Returns\n    -------\n    Sequence[dendropy.Node]\n        Path of nodes in self.tree from this taxon (inclusive) to the root\n        (inclusive).\n    \"\"\"\n    path = []\n    node = self.taxon_to_node[taxon]\n    while node is not self.tree.seed_node:\n        path.append(node)\n        node = node.parent_node\n    path.append(self.root())\n    return path\n</code></pre>"},{"location":"api/#cladecombiner.taxonomy_scheme.PhylogeneticTaxonomyScheme.prune_subtree","title":"<code>prune_subtree(taxon)</code>","text":"<p>Remove subtree corresponding to this taxon and clean up maps</p> <p>Parameters:</p> <ul> <li> <code>taxon</code>               (<code>Taxon</code>)           \u2013            <p>The taxon which is the base of the subtree to be removed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>Edits self.tree in-place.</p> </li> </ul> Source code in <code>cladecombiner/taxonomy_scheme.py</code> <pre><code>def prune_subtree(self, taxon: Taxon) -&gt; None:\n    \"\"\"\n    Remove subtree corresponding to this taxon and clean up maps\n\n    Parameters\n    ----------\n    taxon : Taxon\n        The taxon which is the base of the subtree to be removed.\n\n    Returns\n    -------\n    None\n        Edits self.tree in-place.\n    \"\"\"\n    node = self.taxon_to_node[taxon]\n    node.parent_node.remove_child(node)\n    self.map_from_tree()\n</code></pre>"},{"location":"api/#cladecombiner.taxonomy_scheme.PhylogeneticTaxonomyScheme.root","title":"<code>root()</code>","text":"<p>Typing-safe function to access root, always returns a dendropy.Node.</p> <p>Returns:</p> <ul> <li> <code>Node</code>           \u2013            <p>The root node of the phylogeny underlying this taxonomy scheme.</p> </li> </ul> Source code in <code>cladecombiner/taxonomy_scheme.py</code> <pre><code>def root(self) -&gt; dendropy.Node:\n    \"\"\"\n    Typing-safe function to access root, always returns a dendropy.Node.\n\n    Returns\n    -------\n    dendropy.Node\n        The root node of the phylogeny underlying this taxonomy scheme.\n    \"\"\"\n    if not isinstance(self.tree.seed_node, dendropy.Node):\n        raise RuntimeError(\"Malformed tree has no seed_node\")\n    else:\n        return self.tree.seed_node\n</code></pre>"},{"location":"api/#cladecombiner.taxonomy_scheme.TaxonomyScheme","title":"<code>TaxonomyScheme</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract class for most general casting of Taxonomy</p> <p>Allows hybridization-induced multiple ancestry.</p> Source code in <code>cladecombiner/taxonomy_scheme.py</code> <pre><code>class TaxonomyScheme(ABC):\n    \"\"\"\n    Abstract class for most general casting of Taxonomy\n\n    Allows hybridization-induced multiple ancestry.\n    \"\"\"\n\n    def ancestors(self, taxon: Taxon) -&gt; Collection[Taxon]:\n        \"\"\"\n        All taxa which are between this taxon and the root (including the root).\n\n        Parameters\n        ----------\n        taxon : Taxon\n            The taxon whose ancestors we want.\n\n        Returns\n        -------\n        Collection[Taxon]\n            All unique taxa between this taxon and the root.\n            Empty container if this taxon is the root.\n        \"\"\"\n        if self.is_root(taxon):\n            return set()\n\n        anc = set()\n        queue = list(self.parents(taxon))\n        while queue:\n            tax = queue.pop(0)\n            anc.add(tax)\n            queue = [*queue, list(self.parents(tax))]\n        return anc\n\n    @abstractmethod\n    def children(self, taxon: Taxon) -&gt; Collection[Taxon]:\n        \"\"\"\n        All taxa which are direct children of this taxon.\n\n        Parameters\n        ----------\n        taxon : Taxon\n            The taxon whose children we want.\n\n        Returns\n        -------\n        Collection[Taxon]\n            A collection of the taxa that are direct descendants of this taxon.\n            Returns empty container if this taxon has no children (i.e., if\n            this taxon is a tip taxon).\n        \"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    def descendants(self, taxon: Taxon, tip_only: bool) -&gt; Collection[Taxon]:\n        \"\"\"\n        All taxa which are contained by this taxon.\n\n        Parameters\n        ----------\n        taxon : Taxon\n            The taxon whose descendants we want.\n        tip_only : bool\n            Do we want only tip descendants of this taxon?\n\n        Returns\n        -------\n        Collection[Taxon]\n            If tip_only == True, all tips that are descended from this taxon.\n            Otherwise, a collection of the taxa that descend from this taxon.\n            That is, its children, and its childrens' children, and so forth.\n            Returns empty container if this taxon is a tip.\n        \"\"\"\n        desc = set()\n        queue = list(self.children(taxon))\n        while queue:\n            tax = queue.pop(0)\n            desc.add(tax)\n            queue = [*queue, list(self.children(tax))]\n        return desc\n\n    @abstractmethod\n    def is_root(self, taxon: Taxon) -&gt; bool:\n        \"\"\"\n        Is this the largest taxon that contains all others?\n\n        Parameters\n        ----------\n        taxon: Taxon\n            The taxon to be checked.\n\n        Returns\n        -------\n        bool\n            True if this taxon is the root.\n        \"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    def is_valid_taxon(self, taxon: Taxon) -&gt; bool:\n        \"\"\"\n        Does the scheme recognize this Taxon?\n\n        Parameters\n        ----------\n        taxon: Taxon\n            The taxon to be checked.\n\n        Returns\n        -------\n        bool\n            True if this taxon is valid.\n        \"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    def parents(self, taxon: Taxon) -&gt; Collection[Taxon]:\n        \"\"\"\n        All parent taxa of taxon, e.g. ancestors exactly one level above this taxon.\n\n        Hybridization allows a taxon to have multiple parent taxa.\n\n        Parameters\n        ----------\n        taxon : Taxon\n            The taxon whose parents we want.\n\n        Returns\n        -------\n        Collection[Taxon]\n            A collection of the taxa that are direct parents of this taxon.\n            Returns empty container if this taxon is the root.\n        \"\"\"\n        raise NotImplementedError()\n\n    def validate(self, taxa: Iterable[Taxon]) -&gt; None:\n        nontaxon = [taxon for taxon in taxa if not isinstance(taxon, Taxon)]\n        if len(nontaxon) &gt; 0:\n            raise TypeError(f\"Found invalid non-Taxon inputs: {nontaxon}\")\n        invalid = [taxon for taxon in taxa if not self.is_valid_taxon(taxon)]\n        if len(invalid) &gt; 0:\n            raise ValueError(\n                f\"The following taxa are not recognized by the provided TaxonomyScheme ({self.__repr__()}): {invalid}\"\n            )\n</code></pre>"},{"location":"api/#cladecombiner.taxonomy_scheme.TaxonomyScheme.ancestors","title":"<code>ancestors(taxon)</code>","text":"<p>All taxa which are between this taxon and the root (including the root).</p> <p>Parameters:</p> <ul> <li> <code>taxon</code>               (<code>Taxon</code>)           \u2013            <p>The taxon whose ancestors we want.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Collection[Taxon]</code>           \u2013            <p>All unique taxa between this taxon and the root. Empty container if this taxon is the root.</p> </li> </ul> Source code in <code>cladecombiner/taxonomy_scheme.py</code> <pre><code>def ancestors(self, taxon: Taxon) -&gt; Collection[Taxon]:\n    \"\"\"\n    All taxa which are between this taxon and the root (including the root).\n\n    Parameters\n    ----------\n    taxon : Taxon\n        The taxon whose ancestors we want.\n\n    Returns\n    -------\n    Collection[Taxon]\n        All unique taxa between this taxon and the root.\n        Empty container if this taxon is the root.\n    \"\"\"\n    if self.is_root(taxon):\n        return set()\n\n    anc = set()\n    queue = list(self.parents(taxon))\n    while queue:\n        tax = queue.pop(0)\n        anc.add(tax)\n        queue = [*queue, list(self.parents(tax))]\n    return anc\n</code></pre>"},{"location":"api/#cladecombiner.taxonomy_scheme.TaxonomyScheme.children","title":"<code>children(taxon)</code>  <code>abstractmethod</code>","text":"<p>All taxa which are direct children of this taxon.</p> <p>Parameters:</p> <ul> <li> <code>taxon</code>               (<code>Taxon</code>)           \u2013            <p>The taxon whose children we want.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Collection[Taxon]</code>           \u2013            <p>A collection of the taxa that are direct descendants of this taxon. Returns empty container if this taxon has no children (i.e., if this taxon is a tip taxon).</p> </li> </ul> Source code in <code>cladecombiner/taxonomy_scheme.py</code> <pre><code>@abstractmethod\ndef children(self, taxon: Taxon) -&gt; Collection[Taxon]:\n    \"\"\"\n    All taxa which are direct children of this taxon.\n\n    Parameters\n    ----------\n    taxon : Taxon\n        The taxon whose children we want.\n\n    Returns\n    -------\n    Collection[Taxon]\n        A collection of the taxa that are direct descendants of this taxon.\n        Returns empty container if this taxon has no children (i.e., if\n        this taxon is a tip taxon).\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/#cladecombiner.taxonomy_scheme.TaxonomyScheme.descendants","title":"<code>descendants(taxon, tip_only)</code>  <code>abstractmethod</code>","text":"<p>All taxa which are contained by this taxon.</p> <p>Parameters:</p> <ul> <li> <code>taxon</code>               (<code>Taxon</code>)           \u2013            <p>The taxon whose descendants we want.</p> </li> <li> <code>tip_only</code>               (<code>bool</code>)           \u2013            <p>Do we want only tip descendants of this taxon?</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Collection[Taxon]</code>           \u2013            <p>If tip_only == True, all tips that are descended from this taxon. Otherwise, a collection of the taxa that descend from this taxon. That is, its children, and its childrens' children, and so forth. Returns empty container if this taxon is a tip.</p> </li> </ul> Source code in <code>cladecombiner/taxonomy_scheme.py</code> <pre><code>@abstractmethod\ndef descendants(self, taxon: Taxon, tip_only: bool) -&gt; Collection[Taxon]:\n    \"\"\"\n    All taxa which are contained by this taxon.\n\n    Parameters\n    ----------\n    taxon : Taxon\n        The taxon whose descendants we want.\n    tip_only : bool\n        Do we want only tip descendants of this taxon?\n\n    Returns\n    -------\n    Collection[Taxon]\n        If tip_only == True, all tips that are descended from this taxon.\n        Otherwise, a collection of the taxa that descend from this taxon.\n        That is, its children, and its childrens' children, and so forth.\n        Returns empty container if this taxon is a tip.\n    \"\"\"\n    desc = set()\n    queue = list(self.children(taxon))\n    while queue:\n        tax = queue.pop(0)\n        desc.add(tax)\n        queue = [*queue, list(self.children(tax))]\n    return desc\n</code></pre>"},{"location":"api/#cladecombiner.taxonomy_scheme.TaxonomyScheme.is_root","title":"<code>is_root(taxon)</code>  <code>abstractmethod</code>","text":"<p>Is this the largest taxon that contains all others?</p> <p>Parameters:</p> <ul> <li> <code>taxon</code>               (<code>Taxon</code>)           \u2013            <p>The taxon to be checked.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if this taxon is the root.</p> </li> </ul> Source code in <code>cladecombiner/taxonomy_scheme.py</code> <pre><code>@abstractmethod\ndef is_root(self, taxon: Taxon) -&gt; bool:\n    \"\"\"\n    Is this the largest taxon that contains all others?\n\n    Parameters\n    ----------\n    taxon: Taxon\n        The taxon to be checked.\n\n    Returns\n    -------\n    bool\n        True if this taxon is the root.\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/#cladecombiner.taxonomy_scheme.TaxonomyScheme.is_valid_taxon","title":"<code>is_valid_taxon(taxon)</code>  <code>abstractmethod</code>","text":"<p>Does the scheme recognize this Taxon?</p> <p>Parameters:</p> <ul> <li> <code>taxon</code>               (<code>Taxon</code>)           \u2013            <p>The taxon to be checked.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if this taxon is valid.</p> </li> </ul> Source code in <code>cladecombiner/taxonomy_scheme.py</code> <pre><code>@abstractmethod\ndef is_valid_taxon(self, taxon: Taxon) -&gt; bool:\n    \"\"\"\n    Does the scheme recognize this Taxon?\n\n    Parameters\n    ----------\n    taxon: Taxon\n        The taxon to be checked.\n\n    Returns\n    -------\n    bool\n        True if this taxon is valid.\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/#cladecombiner.taxonomy_scheme.TaxonomyScheme.parents","title":"<code>parents(taxon)</code>  <code>abstractmethod</code>","text":"<p>All parent taxa of taxon, e.g. ancestors exactly one level above this taxon.</p> <p>Hybridization allows a taxon to have multiple parent taxa.</p> <p>Parameters:</p> <ul> <li> <code>taxon</code>               (<code>Taxon</code>)           \u2013            <p>The taxon whose parents we want.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Collection[Taxon]</code>           \u2013            <p>A collection of the taxa that are direct parents of this taxon. Returns empty container if this taxon is the root.</p> </li> </ul> Source code in <code>cladecombiner/taxonomy_scheme.py</code> <pre><code>@abstractmethod\ndef parents(self, taxon: Taxon) -&gt; Collection[Taxon]:\n    \"\"\"\n    All parent taxa of taxon, e.g. ancestors exactly one level above this taxon.\n\n    Hybridization allows a taxon to have multiple parent taxa.\n\n    Parameters\n    ----------\n    taxon : Taxon\n        The taxon whose parents we want.\n\n    Returns\n    -------\n    Collection[Taxon]\n        A collection of the taxa that are direct parents of this taxon.\n        Returns empty container if this taxon is the root.\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/#cladecombiner.taxonomy_scheme.TreelikeTaxonomyScheme","title":"<code>TreelikeTaxonomyScheme</code>","text":"<p>               Bases: <code>TaxonomyScheme</code></p> <p>Abstract class for hybrid-free Taxonomy.</p> <p>Common taxonomic notions that are either ill-defined or require generalization in the face of hybridization are defined here, such as the MRCA of a set of taxa.</p> Source code in <code>cladecombiner/taxonomy_scheme.py</code> <pre><code>class TreelikeTaxonomyScheme(TaxonomyScheme):\n    \"\"\"\n    Abstract class for hybrid-free Taxonomy.\n\n    Common taxonomic notions that are either ill-defined or require\n    generalization in the face of hybridization are defined here, such as the\n    MRCA of a set of taxa.\n    \"\"\"\n\n    ########################\n    # Superclass overrides #\n    ########################\n\n    def ancestors(self, taxon: Taxon) -&gt; Sequence[Taxon]:\n        \"\"\"\n        Postorder sequence of taxa between this taxon and the root (including\n        the root).\n\n        Parameters\n        ----------\n        taxon : Taxon\n            The taxon whose ancestors we want.\n\n        Returns\n        -------\n        Sequence[Taxon]\n            All unique taxa between this taxon and the root, in that order,\n            and including the root. Returns empty container if this taxon is\n            the root.\n        \"\"\"\n        anc = []\n        parent = self.parents(taxon)\n        while parent is not None:\n            anc.append(parent)\n            parent = self.parents(parent)\n        return anc\n\n    @abstractmethod\n    def parents(self, taxon: Taxon) -&gt; Taxon | None:\n        \"\"\"\n        A taxon has only one parent if the scheme is treelike.\n\n        Parameters\n        ----------\n        taxon : Taxon\n            The taxon whose parents we want.\n\n        Returns\n        -------\n        Taxon\n            The taxon's parent, or None if this is the root.\n        \"\"\"\n        raise NotImplementedError()\n\n    #################\n    # Class methods #\n    #################\n\n    @abstractmethod\n    def contains(self, focal: Taxon, target: Taxon) -&gt; bool:\n        \"\"\"\n        Does the focal taxon contain the target taxon?\n\n        That is, is target a descendant of focal?\n\n        Parameters\n        ----------\n        focal : Taxon\n            This taxon may or may not contain the target taxon.\n        target : Taxon\n            The taxon which may or may not be contained by the focal taxon.\n\n        Returns\n        -------\n        bool\n            True if focal contains target.\n        \"\"\"\n        raise NotImplementedError()\n\n    @abstractmethod\n    def mrca(self, taxa: Iterable[Taxon]) -&gt; Taxon:\n        \"\"\"\n        Find the MRCA of a set of taxa\n\n        The MRCA is the most recent common ancestor of a set of taxa. There\n        are potentially many common ancestors of a particular group of taxa,\n        but this is the one which contains the fewest other taxa possible.\n\n        Parameters\n        ----------\n        taxa : Iterable[Taxon]\n            The taxa for which we want the MRCA.\n\n        Returns\n        -------\n        Taxon\n            The MRCA.\n        \"\"\"\n        raise NotImplementedError()\n</code></pre>"},{"location":"api/#cladecombiner.taxonomy_scheme.TreelikeTaxonomyScheme.ancestors","title":"<code>ancestors(taxon)</code>","text":"<p>Postorder sequence of taxa between this taxon and the root (including the root).</p> <p>Parameters:</p> <ul> <li> <code>taxon</code>               (<code>Taxon</code>)           \u2013            <p>The taxon whose ancestors we want.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Sequence[Taxon]</code>           \u2013            <p>All unique taxa between this taxon and the root, in that order, and including the root. Returns empty container if this taxon is the root.</p> </li> </ul> Source code in <code>cladecombiner/taxonomy_scheme.py</code> <pre><code>def ancestors(self, taxon: Taxon) -&gt; Sequence[Taxon]:\n    \"\"\"\n    Postorder sequence of taxa between this taxon and the root (including\n    the root).\n\n    Parameters\n    ----------\n    taxon : Taxon\n        The taxon whose ancestors we want.\n\n    Returns\n    -------\n    Sequence[Taxon]\n        All unique taxa between this taxon and the root, in that order,\n        and including the root. Returns empty container if this taxon is\n        the root.\n    \"\"\"\n    anc = []\n    parent = self.parents(taxon)\n    while parent is not None:\n        anc.append(parent)\n        parent = self.parents(parent)\n    return anc\n</code></pre>"},{"location":"api/#cladecombiner.taxonomy_scheme.TreelikeTaxonomyScheme.contains","title":"<code>contains(focal, target)</code>  <code>abstractmethod</code>","text":"<p>Does the focal taxon contain the target taxon?</p> <p>That is, is target a descendant of focal?</p> <p>Parameters:</p> <ul> <li> <code>focal</code>               (<code>Taxon</code>)           \u2013            <p>This taxon may or may not contain the target taxon.</p> </li> <li> <code>target</code>               (<code>Taxon</code>)           \u2013            <p>The taxon which may or may not be contained by the focal taxon.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if focal contains target.</p> </li> </ul> Source code in <code>cladecombiner/taxonomy_scheme.py</code> <pre><code>@abstractmethod\ndef contains(self, focal: Taxon, target: Taxon) -&gt; bool:\n    \"\"\"\n    Does the focal taxon contain the target taxon?\n\n    That is, is target a descendant of focal?\n\n    Parameters\n    ----------\n    focal : Taxon\n        This taxon may or may not contain the target taxon.\n    target : Taxon\n        The taxon which may or may not be contained by the focal taxon.\n\n    Returns\n    -------\n    bool\n        True if focal contains target.\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/#cladecombiner.taxonomy_scheme.TreelikeTaxonomyScheme.mrca","title":"<code>mrca(taxa)</code>  <code>abstractmethod</code>","text":"<p>Find the MRCA of a set of taxa</p> <p>The MRCA is the most recent common ancestor of a set of taxa. There are potentially many common ancestors of a particular group of taxa, but this is the one which contains the fewest other taxa possible.</p> <p>Parameters:</p> <ul> <li> <code>taxa</code>               (<code>Iterable[Taxon]</code>)           \u2013            <p>The taxa for which we want the MRCA.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Taxon</code>           \u2013            <p>The MRCA.</p> </li> </ul> Source code in <code>cladecombiner/taxonomy_scheme.py</code> <pre><code>@abstractmethod\ndef mrca(self, taxa: Iterable[Taxon]) -&gt; Taxon:\n    \"\"\"\n    Find the MRCA of a set of taxa\n\n    The MRCA is the most recent common ancestor of a set of taxa. There\n    are potentially many common ancestors of a particular group of taxa,\n    but this is the one which contains the fewest other taxa possible.\n\n    Parameters\n    ----------\n    taxa : Iterable[Taxon]\n        The taxa for which we want the MRCA.\n\n    Returns\n    -------\n    Taxon\n        The MRCA.\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/#cladecombiner.taxonomy_scheme.TreelikeTaxonomyScheme.parents","title":"<code>parents(taxon)</code>  <code>abstractmethod</code>","text":"<p>A taxon has only one parent if the scheme is treelike.</p> <p>Parameters:</p> <ul> <li> <code>taxon</code>               (<code>Taxon</code>)           \u2013            <p>The taxon whose parents we want.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Taxon</code>           \u2013            <p>The taxon's parent, or None if this is the root.</p> </li> </ul> Source code in <code>cladecombiner/taxonomy_scheme.py</code> <pre><code>@abstractmethod\ndef parents(self, taxon: Taxon) -&gt; Taxon | None:\n    \"\"\"\n    A taxon has only one parent if the scheme is treelike.\n\n    Parameters\n    ----------\n    taxon : Taxon\n        The taxon whose parents we want.\n\n    Returns\n    -------\n    Taxon\n        The taxon's parent, or None if this is the root.\n    \"\"\"\n    raise NotImplementedError()\n</code></pre>"},{"location":"api/#cladecombiner.tree_utils","title":"<code>cladecombiner.tree_utils</code>","text":""},{"location":"api/#cladecombiner.tree_utils.add_paraphyletic_tips","title":"<code>add_paraphyletic_tips(phy, tips)</code>","text":"<p>Disambiguates ancestral versus tip taxa by adding tips explicitly.</p> <p>Assumes all nodes have labels.</p> <p>In nomenclatures for evolving pathogens, naming a new taxon will make a previously-named taxon paraphyletic. There can then be ambiguity with respect to whether that previous taxon name is being used to refer to the monophyletic group comprising this taxon and all its descendants, or the non-monophyletic group of the previous taxon except its newly named descendant.</p> <p>This function adds a tip to the phylogeny to represent the non-monophyletic group which has been split by subsequently-named taxa.</p> <p>For example, the SARS-CoV-2 Pango taxon JN.1 could mean the higher taxon JN.1 (which includes many more specifically-named taxa, such as JN.1.11.1 (KP) and JN.1.30.1 (KU)), or JN.1 as something we can observe as a label for sampled sequences. The latter of these means a non-more-specifically-named JN.1 lineage, some part of the tree of JN.1 which has not been named more specifically. This also occurs with NextStrain clades, for example the SARS-CoV-2 clade 23I was made paraphyletic with respect to 24A, which was in turn made paraphyletic by 24B. So 23I can mean an ancestral taxon, comprising all lineages in any of these clades, or a non-more-specifically named part of the 23I tree, which we could see in a sample at the same time as we see 24A.</p> <p>Parameters:</p> <ul> <li> <code>phy</code>               (<code>dendropy.Tree with a label for all nodes</code>)           \u2013            <p>The tree to which we will add the tips.</p> </li> <li> <code>tips</code>               (<code>Sequence[str]</code>)           \u2013            <p>The names of taxa that should exist as both ancestral and tip taxa.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tree</code>           \u2013            <p>The tree with all added tips.</p> </li> </ul> Source code in <code>cladecombiner/tree_utils.py</code> <pre><code>def add_paraphyletic_tips(\n    phy: dendropy.Tree, tips: Sequence[str]\n) -&gt; dendropy.Tree:\n    \"\"\"\n    Disambiguates ancestral versus tip taxa by adding tips explicitly.\n\n    Assumes all nodes have labels.\n\n    In nomenclatures for evolving pathogens, naming a new taxon will make\n    a previously-named taxon paraphyletic. There can then be ambiguity with\n    respect to whether that previous taxon name is being used to refer to\n    the monophyletic group comprising this taxon and all its descendants,\n    or the non-monophyletic group of the previous taxon except its newly\n    named descendant.\n\n    This function adds a tip to the phylogeny to represent the\n    non-monophyletic group which has been split by subsequently-named\n    taxa.\n\n    For example, the SARS-CoV-2 Pango taxon JN.1 could mean the higher\n    taxon JN.1 (which includes many more specifically-named taxa, such as\n    JN.1.11.1 (KP) and JN.1.30.1 (KU)), or JN.1 as something we can\n    observe as a label for sampled sequences. The latter of these means a\n    non-more-specifically-named JN.1 lineage, some part of the tree of JN.1\n    which has not been named more specifically. This also occurs with\n    NextStrain clades, for example the SARS-CoV-2 clade 23I was made\n    paraphyletic with respect to 24A, which was in turn made paraphyletic\n    by 24B. So 23I can mean an ancestral taxon, comprising all lineages in\n    any of these clades, or a non-more-specifically named part of the 23I\n    tree, which we could see in a sample at the same time as we see 24A.\n\n    Parameters\n    ---------\n    phy : dendropy.Tree with a label for all nodes\n        The tree to which we will add the tips.\n    tips : Sequence[str]\n        The names of taxa that should exist as both ancestral and tip taxa.\n\n    Returns\n    -------\n    dendropy.Tree\n        The tree with all added tips.\n    \"\"\"\n    tree = phy.clone(2)\n    to_add = []\n    for node in tree.preorder_node_iter():\n        if node.is_internal():\n            if node.label in tips:\n                tip = dendropy.Node(label=node.label)\n                to_add.append(\n                    (\n                        node,\n                        tip,\n                    )\n                )\n    for nt in to_add:\n        nt[0].add_child(nt[1])\n\n    return tree\n</code></pre>"},{"location":"api/#cladecombiner.tree_utils.fully_labeled_subtrees_same","title":"<code>fully_labeled_subtrees_same(node1, node2)</code>","text":"<p>Are two subtrees with every node labeled topologically equivalent?</p> <p>Used by fully_labeled_trees_same().</p> <p>Recursive function, calls itself until either a difference is seen or all tips in the subtree in both tree 1 and tree 2 are seen.</p> <p>Parameters:</p> <ul> <li> <code>node1</code>               (<code>Node</code>)           \u2013            <p>Node defining the subtree in tree 1.</p> </li> <li> <code>node2</code>               (<code>Node</code>)           \u2013            <p>Node defining the subtree in tree 2.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the subtrees are the same.</p> </li> </ul> Source code in <code>cladecombiner/tree_utils.py</code> <pre><code>def fully_labeled_subtrees_same(\n    node1: dendropy.Node, node2: dendropy.Node\n) -&gt; bool:\n    \"\"\"\n    Are two subtrees with every node labeled topologically equivalent?\n\n    Used by fully_labeled_trees_same().\n\n    Recursive function, calls itself until either a difference is seen or all\n    tips in the subtree in both tree 1 and tree 2 are seen.\n\n    Parameters\n    ---------\n    node1 : dendropy.Node\n        Node defining the subtree in tree 1.\n    node2 : dendropy.Node\n        Node defining the subtree in tree 2.\n\n    Returns\n    -------\n    bool\n        True if the subtrees are the same.\n    \"\"\"\n    children1 = node1.child_nodes()\n    children2 = node2.child_nodes()\n\n    child_labels1 = [child.label for child in children1].sort()\n    child_labels2 = [child.label for child in children2].sort()\n\n    if not child_labels1 == child_labels2:\n        return False\n\n    for child1 in children1:\n        for child2 in children2:\n            if child1.label == child2.label:\n                fully_labeled_subtrees_same(child1, child2)\n\n    return True\n</code></pre>"},{"location":"api/#cladecombiner.tree_utils.fully_labeled_trees_same","title":"<code>fully_labeled_trees_same(tree1, tree2)</code>","text":"<p>Are two trees with every node labeled topologically equivalent?</p> <p>Standard topological identity means that two trees portray the same evolutionary relationships between the tips. This function assumes that every internal node is labeled and checks the relationships between all nodes.</p> <p>Calls fully_labeled_subtrees_same() to recursively evaluate subtrees.</p> <p>Parameters:</p> <ul> <li> <code>tree1</code>               (<code>Tree</code>)           \u2013            <p>One tree to compare.</p> </li> <li> <code>tree2</code>               (<code>Tree</code>)           \u2013            <p>The other tree to compare.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the trees are the same.</p> </li> </ul> Source code in <code>cladecombiner/tree_utils.py</code> <pre><code>def fully_labeled_trees_same(\n    tree1: dendropy.Tree, tree2: dendropy.Tree\n) -&gt; bool:\n    \"\"\"\n    Are two trees with every node labeled topologically equivalent?\n\n    Standard topological identity means that two trees portray the same\n    evolutionary relationships between the tips. This function assumes that\n    every internal node is labeled and checks the relationships between all\n    nodes.\n\n    Calls fully_labeled_subtrees_same() to recursively evaluate subtrees.\n\n    Parameters\n    ---------\n    tree1 : dendropy.Tree\n        One tree to compare.\n    tree2 : dendropy.Tree\n        The other tree to compare.\n\n    Returns\n    -------\n    bool\n        True if the trees are the same.\n    \"\"\"\n    if isinstance(tree1.seed_node, dendropy.Node) and isinstance(\n        tree2.seed_node, dendropy.Node\n    ):\n        if tree1.seed_node.label != tree2.seed_node.label:\n            return False\n        else:\n            return fully_labeled_subtrees_same(\n                tree1.seed_node, tree2.seed_node\n            )\n    else:\n        # Should never hit, required for type checking\n        raise RuntimeError(\"Malformed tree, seed_node must be a dendropy.Node\")\n</code></pre>"},{"location":"api/#cladecombiner.tree_utils.prune_nonancestral","title":"<code>prune_nonancestral(phy, tips)</code>","text":"<p>Prune a tree to only contain portions ancestral to provided tip taxa.</p> <p>Tree is assumed to be node labeled as a PhylogeneticTaxonomyScheme.tree.</p> <p>Parameters:</p> <ul> <li> <code>phy</code>               (<code>dendropy.Tree with a label for all nodes</code>)           \u2013            <p>The tree which we are to prune.</p> </li> <li> <code>tips</code>               (<code>Iterable[str]</code>)           \u2013            <p>The names of the only tips to be found in the desired pruned tree.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tree</code>           \u2013            <p>The tree pruned to only portions ancestral to the tips.</p> </li> </ul> Source code in <code>cladecombiner/tree_utils.py</code> <pre><code>def prune_nonancestral(\n    phy: dendropy.Tree, tips: Iterable[str]\n) -&gt; dendropy.Tree:\n    \"\"\"\n    Prune a tree to only contain portions ancestral to provided tip taxa.\n\n    Tree is assumed to be node labeled as a PhylogeneticTaxonomyScheme.tree.\n\n    Parameters\n    ---------\n    phy : dendropy.Tree with a label for all nodes\n        The tree which we are to prune.\n    tips : Iterable[str]\n        The names of the only tips to be found in the desired pruned tree.\n\n    Returns\n    -------\n    dendropy.Tree\n        The tree pruned to only portions ancestral to the tips.\n    \"\"\"\n    tree = phy.clone(2)\n    assert all(node.label is not None for node in tree.postorder_node_iter())\n\n    target_tips = set(tips)\n    tree_tips = set([leaf.label for leaf in tree.leaf_node_iter()])\n    assert target_tips.issubset(\n        tree_tips\n    ), f\"Tree is missing target tips {target_tips.difference(tree_tips)}\"\n\n    unobserved = []\n    assert isinstance(tree.seed_node, dendropy.Node)\n\n    _find_unobserved_subtrees(tree.seed_node, target_tips, unobserved)\n    for node in unobserved:\n        tree.prune_subtree(node, suppress_unifurcations=False)\n\n    for leaf in tree.leaf_node_iter():\n        if (\n            leaf.parent_node.label == leaf.label\n            and len(leaf.parent_node.child_nodes()) == 1\n        ):\n            tree.prune_subtree(leaf, suppress_unifurcations=False)\n    return tree\n</code></pre>"},{"location":"api/#cladecombiner.tree_utils.tree_from_edge_dict","title":"<code>tree_from_edge_dict(child_parent)</code>","text":"<p>Turns a {child : parent} dictionary of taxon names into a dendropy Tree.</p> <p>Parameters:</p> <ul> <li> <code>child_parent</code>               (<code>Optional[dict[str, list[str]]]</code>)           \u2013            <p>Dict giving parent taxon for all non-root taxa.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PhylogeneticTaxonomyScheme</code>           \u2013            <p>A PhylogeneticTaxonomyScheme using the tree specified by the given dict.</p> </li> </ul> Source code in <code>cladecombiner/tree_utils.py</code> <pre><code>def tree_from_edge_dict(\n    child_parent: dict[str, str],\n) -&gt; dendropy.Tree:\n    \"\"\"\n    Turns a {child : parent} dictionary of taxon names into a dendropy Tree.\n\n    Parameters\n    ---------\n    child_parent : Optional[dict[str, list[str]]]\n        Dict giving parent taxon for all non-root taxa.\n\n    Returns\n    -------\n    PhylogeneticTaxonomyScheme\n        A PhylogeneticTaxonomyScheme using the tree specified by the given dict.\n    \"\"\"\n    children = set(child_parent.keys())\n    parents = set(child_parent.values())\n\n    roots = parents.difference(children)\n    assert (\n        len(roots) == 1\n    ), f\"There should be one root, not {len(roots)}. Found {roots}.\"\n    str_root = roots.pop()\n\n    parent_child = {}\n    for k, v in child_parent.items():\n        if v in parent_child:\n            parent_child[v].append(k)\n        else:\n            parent_child[v] = [k]\n\n    str_taxa = list(children)\n    str_taxa.append(str_root)\n    taxon_namespace = dendropy.TaxonNamespace(str_taxa)\n    tree = dendropy.Tree(taxon_namespace=taxon_namespace)\n\n    assert tree.seed_node is not None\n    tree.seed_node.label = str_root\n    _add_edict_children(tree.seed_node, str_root, parent_child)\n\n    return tree\n</code></pre>"},{"location":"api/#cladecombiner.tree_utils.tree_from_edge_table_string","title":"<code>tree_from_edge_table_string(edge_table, delimiter, parent_col, child_col)</code>","text":"Source code in <code>cladecombiner/tree_utils.py</code> <pre><code>def tree_from_edge_table_string(\n    edge_table: str,\n    delimiter: str,\n    parent_col: str | int,\n    child_col: str | int,\n):\n    \"\"\" \"\"\"\n    if isinstance(parent_col, str) and isinstance(child_col, str):\n        use_names = True\n    elif isinstance(parent_col, int) and isinstance(child_col, int):\n        use_names = False\n    else:\n        raise TypeError(\n            \"Must specify either indices or names for extracting columns.\"\n        )\n\n    if use_names:\n        reader = csv.DictReader(edge_table.split(\"\\n\"), delimiter=delimiter)\n    else:\n        reader = csv.reader(edge_table.split(\"\\n\"), delimiter=delimiter)\n\n    child_parent = {row[child_col]: row[parent_col] for row in reader}  # type: ignore #pylance can't track that we've already sanitized this\n\n    return tree_from_edge_dict(child_parent)\n</code></pre>"},{"location":"as_of_agg/","title":"As-of aggregation","text":"<p>As-of aggregation is a tool that can be used to approximate the taxon labels that would have been assigned to sequences on a prior (as-of) date given the taxon labels assigned on a later date. Without loss of generality, take the later date to be the present. Historical aggregation approximation takes in: - Current taxa (whose labels were assigned with the current version of the assignment tool) as <code>input_taxa</code>. - The current taxonomy tree (in the form of a <code>PhylogeneticTaxonomyScheme</code>). - Information regarding what taxon names were recognized on the as-of date (this comes from a <code>HistoryAwareNomenclature</code>).</p> <p>It outputs an <code>Aggregation</code> mapping each current taxon to the most recent ancestor which was recognized on the as-of date.</p> <p>\u26a0\ufe0f If it is feasible to re-run sequence assignment on sequence data from the as-of date using the appropriate version of the assignment tool for that date, it is recommended that you do so. (See for example Cladetime.) \u26a0\ufe0f</p>"},{"location":"as_of_agg/#in-practice","title":"In practice","text":"<p>We will continue with the taxa from \"Phylogenetic aggregation to fixed targets.\" If you have not read that part of the documentation, you may wish to do so before proceeding.</p> <pre><code>import cladecombiner\nfrom cladecombiner import pango_sc2_nomenclature as pn\n\nlineages = [\n    \"BA.2\",\n    \"BA.2.86\",\n    \"XCU\",\n    \"XDQ\",\n    \"BQ.1.1.23\",\n    \"JN.6\",\n    \"JN.1.9.1\",\n    \"JN.9\",\n    \"KP.1.1\",\n    \"FW.1.1.1\",\n    \"BA.5.2.6\",\n]\n\ntaxa = [cladecombiner.Taxon(lin, True) for lin in lineages]\n\npn.setup_alias_map()\ntree = pn.taxonomy_tree(taxa)\n\nscheme = cladecombiner.PhylogeneticTaxonomyScheme(tree)\n</code></pre> <p>Let us take our as-of date to be 2023-01-01. In fact, we really need to specify a date, time, and timezone (historical information is obtained through git histories using time stamps), but cladecombiner handles that under the hood. (The state as of last commit before 0:00:00 the day after the as-of day will be used.) Note that the call to set up the <code>AsOfAggregator</code> requires an internet connection (so that we can search the history of the public repository containing the data). <pre><code>import datetime\nagg = cladecombiner.AsOfAggregator(taxonomy_scheme=scheme, versioning_provider=pn, as_of=datetime.datetime(2023, 1, 2))\n</code></pre></p> <p>We can now aggregate our input taxa.</p> <pre><code>res = agg.aggregate(taxa)\n</code></pre> <p>This yields the following <code>Aggregation</code>:</p> <pre><code>Taxon(BA.5.2.6, tip=True)  : Taxon(BA.5.2.6, tip=True)\nTaxon(BQ.1.1.23, tip=True) : Taxon(BQ.1.1.23, tip=True)\nTaxon(XCU, tip=True)       : Taxon(XBC.1, tip=False)\nTaxon(FW.1.1.1, tip=True)  : Taxon(XBB.1, tip=False)\nTaxon(JN.1.9.1, tip=True)  : Taxon(BA.2, tip=False)\nTaxon(JN.6, tip=True)      : Taxon(BA.2, tip=False)\nTaxon(JN.9, tip=True)      : Taxon(BA.2, tip=False)\nTaxon(KP.1.1, tip=True)    : Taxon(BA.2, tip=False)\nTaxon(XDQ, tip=True)       : Taxon(BA.2, tip=False)\nTaxon(BA.2, tip=True)      : Taxon(BA.2, tip=False)\nTaxon(BA.2.86, tip=True)   : Taxon(BA.2, tip=False)\n</code></pre> <p>Several of these taxa were recognized on the as-of date, and so they map to themselves. The rest map to the most recent available ancestor.</p> <p>Note that if the current tree has both an internal node (<code>Taxon(name, tip=False)</code>) and a tip node (<code>Taxon(name, tip=True)</code>) for a taxon, aggregation will be to the internal node. Thus, while in our input data we have <code>Taxon(BA.2, tip=True)</code>, we place it in <code>Taxon(BA.2, tip=False)</code>.</p>"},{"location":"fixed_agg_workflow/","title":"Phylogenetic aggregation to fixed targets","text":"<p>Using the <code>BasicPhylogeneticAggregator</code>, we can phylogenetically aggregate a set of observed taxa into a pre-defined set of aggregated taxa.</p> <p>That is, if we already know what aggregated taxa we want, we can use the <code>BasicPhylogeneticAggregator</code> to do this such that:</p> <ul> <li>Explicit mappings can be recorded for all taxa (by storing the python <code>dict</code> to json)</li> <li>The addition of new taxa to the input data can be handled with minimal pain (by re-running the same python code on the new input file)</li> </ul>"},{"location":"fixed_agg_workflow/#observed-taxa","title":"Observed taxa","text":"<p>First, we need to get the observed taxa as <code>cladecombiner.Taxon</code> objects. If these are in a file, we can read them in:</p> <pre><code>import cladecombiner\n\ntaxa = cladecombiner.read_taxa(\"path/to/file\")\n</code></pre> <p>If we already have these as a list of strings in python, we can convert them:</p> <pre><code>import cladecombiner\n\nlineages = [\n    \"BA.2\",\n    \"BA.2.86\",\n    \"XCU\",\n    \"XDQ\",\n    \"BQ.1.1.23\",\n    \"JN.6\",\n    \"JN.1.9.1\",\n    \"JN.9\",\n    \"KP.1.1\",\n    \"FW.1.1.1\",\n    \"BA.5.2.6\",\n]\n\ntaxa = [cladecombiner.Taxon(lin, True) for lin in lineages]\n</code></pre> <p>Note that we are declaring these to all be tip taxa. Internally, aggregation is simpler when we treat everything we can observe directly as a tip in the taxonomy tree. For more on this distinction, see here.</p>"},{"location":"fixed_agg_workflow/#creating-the-taxonomy-scheme","title":"Creating the taxonomy scheme","text":"<p>Aggregating phylogenetically requires us to create a <code>PhylogeneticTaxonomyScheme</code>. We do this by using Pango nomenclature's rules to get the taxonomic tree relating the observed lineages, and creating a taxonomy scheme from it. We need access the alias json for Pango SARS-CoV-2 lineages so that we know that, for example, BA is B.1.1.529. By default, cladecombiner automatically retrieves the latest version from the pango-designation git repo.</p> <pre><code>from cladecombiner import pango_sc2_nomenclature as pn\n\npn.setup_alias_map()\ntree = pn.taxonomy_tree(taxa)\n\nscheme = cladecombiner.PhylogeneticTaxonomyScheme(tree)\n</code></pre> <p>These trees are wrappers around <code>dendropy.Tree</code> objects, and can be printed to screen for inspection. The command <code>print(tree.as_ascii_plot(plot_metric=\"level\", show_internal_node_labels=False))</code> will, for these taxa, yield</p> <pre><code>                         /----+---- BA.5.2.6\n                    /----+\n                    |    \\----+----+----+----+----+----+----+---- BQ.1.1.23\n                    |\n                    |                   /----+----+----+---- KP.1.1\n                    |              /----+\n                    |              |    \\----+---- JN.1.9.1\n                    |              |\n+----+----+----+----+         /----+---- XDQ\n                    |         |    |\n                    |         |    |---- JN.9\n                    |    /----+    |\n                    |    |    |    \\---- JN.6\n                    |    |    |\n                    |    |    \\---- BA.2.86\n                    \\----+\n                         |----+----+----+----+----+----+----+----+----+---- FW.1.1.1\n                         |\n                         |----+----+----+----+---- XCU\n                         |\n                         \\---- BA.2\n</code></pre> <p>The observed taxa are all tips, and the internal nodes are represented by <code>+</code> (names not shown for compactness, set <code>show_internal_node_labels=True</code> to see these). Some of these nodes here have only one child, while others have many, because cladecombiner makes this tree to include every named Pango lineage in the complete histories of all lineages. Thus, the first four nodes are the root (in cladecombiner parlance, an empty string, <code>\"\"</code>), B, B.1, B.1.1, and B.1.1.529 (aka BA, but note that cladecombiner is pedantic about names and does not accept naked aliases like BA). Of these, only BA has multiple children among the observed lineages, so only it is a branching point in the tree.</p>"},{"location":"fixed_agg_workflow/#aggregation-targets","title":"Aggregation targets","text":"<p>We also need the desired aggregation targets, the taxa to which we want to aggregate. As with observed taxa, we can read these in or create them from strings. Let us assume we want to aggregate to BA.2.86.1 (aka JN), BA.2, BA.5, and KP.1.1.</p> <p>Aggregation requires us to be explicit about whether we are truly aggregating or not. Three of these represent actual aggregations of the observed taxa, as we have observed lineages which are children of BA.2, BA.5, and JN. However, as we have no children of KP.1.1 in our observed lineages, it is a tip. In order to keep tip taxa we want as aggregation targets from being added to any higher taxa which contain them, we must specify self-mappings for each of them due to the algorithm for nested taxa.</p> <pre><code>target_taxa = [\n    cladecombiner.Taxon(\"BA.2\", False),\n    cladecombiner.Taxon(\"BA.2.86.1\", False),\n    cladecombiner.Taxon(\"BA.5\", False),\n    cladecombiner.Taxon(\"KP.1.1\", True),\n]\n</code></pre>"},{"location":"fixed_agg_workflow/#aggregate","title":"Aggregate","text":"<p>We are now ready to create an aggregation object and aggregate.</p> <pre><code>agg = cladecombiner.BasicPhylogeneticAggregator(targets=target_taxa, taxonomy_scheme=scheme)\n\nres = agg.aggregate(input_taxa)\n</code></pre> <p>The <code>res</code> object is an <code>Aggregation</code> object, essentially just a <code>dict[Taxon, Taxon]</code>, which maps each of the observed lineages in <code>taxa</code> to some aggregated taxon. For the above input taxa and targets, the resulting mapping is:</p> <pre><code>Taxon(KP.1.1, tip=True)    : Taxon(KP.1.1, tip=True)\nTaxon(BA.5.2.6, tip=True)  : Taxon(BA.5, tip=False)\nTaxon(BQ.1.1.23, tip=True) : Taxon(BA.5, tip=False)\nTaxon(JN.1.9.1, tip=True)  : Taxon(BA.2.86.1, tip=False)\nTaxon(XDQ, tip=True)       : Taxon(BA.2.86.1, tip=False)\nTaxon(JN.9, tip=True)      : Taxon(BA.2.86.1, tip=False)\nTaxon(JN.6, tip=True)      : Taxon(BA.2.86.1, tip=False)\nTaxon(XCU, tip=True)       : Taxon(BA.2, tip=False)\nTaxon(BA.2.86, tip=True)   : Taxon(BA.2, tip=False)\nTaxon(FW.1.1.1, tip=True)  : Taxon(BA.2, tip=False)\nTaxon(BA.2, tip=True)      : Taxon(BA.2, tip=False)\n</code></pre>"},{"location":"fixed_agg_workflow/#using-and-saving-the-aggregation","title":"Using and saving the aggregation","text":"<p>The resulting mapping can be used to rename taxa in, for example, line list data. A <code>dict[str,str]</code> can be obtained via <code>res.to_str()</code> which can be fed into the <code>replace</code> methods in pandas or polars.</p> <p>The <code>res.to_str()</code> dictionary can be saved for posterity by writing to file using python's <code>json.dumps()</code> function.</p> <p>Saving the python script for posterity is also recommended. Where the saved map is an exact record of how the particular input taxa were mapped, the script can be used on a new set of input taxa to produce a new mapping.</p>"},{"location":"fixed_agg_workflow/#important-settings","title":"Important settings","text":"<p>When creating the <code>BasicPhylogeneticAggregator</code>, there are two important arguments: <code>off_target</code> and <code>sort_clades</code>.</p>"},{"location":"fixed_agg_workflow/#off_target","title":"<code>off_target</code>","text":"<p>The mapping for a taxon which does not have an ancestor in the <code>targets</code> is determined by <code>off_target</code>, which can be:</p> <ul> <li><code>\"other\"</code> to put all such taxa into <code>Taxon(other, tip=False)</code>. This is the default.</li> <li><code>\"self\"</code> to map all such taxa to themselves.</li> </ul> <p>For example, if we hadn't included BA.2 in the targets, then the resulting map would have been, by default,</p> <pre><code>Taxon(KP.1.1, tip=True)    : Taxon(KP.1.1, tip=True)\nTaxon(BA.5.2.6, tip=True)  : Taxon(BA.5, tip=False)\nTaxon(BQ.1.1.23, tip=True) : Taxon(BA.5, tip=False)\nTaxon(JN.1.9.1, tip=True)  : Taxon(BA.2.86.1, tip=False)\nTaxon(XDQ, tip=True)       : Taxon(BA.2.86.1, tip=False)\nTaxon(JN.9, tip=True)      : Taxon(BA.2.86.1, tip=False)\nTaxon(JN.6, tip=True)      : Taxon(BA.2.86.1, tip=False)\nTaxon(XCU, tip=True)       : Taxon(other, tip=False)\nTaxon(BA.2.86, tip=True)   : Taxon(other, tip=False)\nTaxon(FW.1.1.1, tip=True)  : Taxon(other, tip=False)\nTaxon(BA.2, tip=True)      : Taxon(other, tip=False)\n</code></pre>"},{"location":"fixed_agg_workflow/#sort_clades","title":"<code>sort_clades</code>","text":"<p>The order in which clades are processed is important and is determined by <code>sort_clades</code>. When we process target a clade, we map all of its children to it, and then remove them from the pool of unmapped taxa. Thus, when nested target taxa are present, the order in which taxa are processed determines the mapping.</p> <ul> <li>If <code>sort_clades</code> is <code>True</code>, then we process clades so that, when clade X contains clade Y, we always aggregate to Y before X. In other words, this approach creates aggregated taxa starting from the smallest/lowest-ranked (least-inclusive) taxon in any nested set and working its way to the root. Thus, we process KP.1.1 before BA.2.86.1.1, and BA.2.86.1 before BA.2. The resulting aggregated taxa might better be termed BA.5, KP.1.1, non-KP.1.1 BA.2.86, and non-BA.2.86.1 BA.2. This is the default.</li> <li>If <code>sort_clades</code> is <code>False</code>, then we process clades in the order they are listed. As BA.2 is listed before BA.2.86.1 in the above declaration of <code>target_taxa</code>, all children of BA.2.86.1 would end up mapped to BA.2, and the aggregation would be   <pre><code>Taxon(XCU, tip=True)       : Taxon(BA.2, tip=False)\nTaxon(BA.2.86, tip=True)   : Taxon(BA.2, tip=False)\nTaxon(FW.1.1.1, tip=True)  : Taxon(BA.2, tip=False)\nTaxon(JN.1.9.1, tip=True)  : Taxon(BA.2, tip=False)\nTaxon(BA.2, tip=True)      : Taxon(BA.2, tip=False)\nTaxon(XDQ, tip=True)       : Taxon(BA.2, tip=False)\nTaxon(JN.9, tip=True)      : Taxon(BA.2, tip=False)\nTaxon(JN.6, tip=True)      : Taxon(BA.2, tip=False)\nTaxon(KP.1.1, tip=True)    : Taxon(BA.2, tip=False)\nTaxon(BA.5.2.6, tip=True)  : Taxon(BA.5, tip=False)\nTaxon(BQ.1.1.23, tip=True) : Taxon(BA.5, tip=False)\n</code></pre></li> </ul>"},{"location":"other_systems/","title":"Other nomenclatures and taxonomies","text":""},{"location":"other_systems/#nextstrain-sars-cov-2-clades","title":"Nextstrain SARS-CoV-2 clades","text":"<p>In addition to user-ready Pango nomenclature and taxonomy tools for SARS-CoV-2 (as featured throughout the documentation), cladecombiner provides user-ready tools for Nextstrain clades of SARS-CoV-2. The workflow is parallel to that for Pango lineages for SARS-CoV-2, starting with a <code>Nomenclature</code> and then defining a <code>PhylogeneticTaxonomyScheme</code> for the relevant taxa.</p> <p>Unlike <code>cladecombiner.pango_sc2_nomenclature</code> which has some useful functionality without an internet connection, <code>cladecombiner.nextstrain_sc2_nomenclature</code> must be able to access the <code>nextstrain/ncov</code> repo (via PyGithub) in order to be used for essentially all tasks. There will be some delay the first time this object is used as files are read from the repo.</p> <p>We can use the <code>Nomenclature</code> for basic tasks, like validating names.</p> <pre><code>import cladecombiner\n\nns = cladecombiner.nextstrain_sc2_nomenclature\n\nns.is_valid_name(\"JN.1\")\n# False\n</code></pre> <p>We can also get taxonomy trees from the nomenclature, such as for all the 2024 clades. <pre><code>taxa = [\n    cladecombiner.Taxon(taxon, True)\n    for taxon in ['24A', '24B', '24C', '24D', '24E', '24F', '24G', '24H', '24I']\n]\n\ntree = ns.taxonomy_tree(taxa)\n</code></pre></p> <p>We can view the tree with <code>print(tree.as_ascii_plot(plot_metric=\"level\", show_internal_node_labels=True))</code>, yielding: <pre><code>                                                                        /-------- 24E\n                                                               /--------24C\n                                                               |        \\-------- 24C\n                                                      /--------24B\n                                                      |        |-------- 24G\n                                                      |        |\n                                                      |        \\-------- 24B\n                                                      |\n                                    /--------23I------24A------ 24F\n                                    |                 |\n                                    |                 |-------- 24H\n                                    |                 |\n19A------20A------20B------21M------21L               |-------- 24I\n                                    |                 |\n                                    |                 \\-------- 24A\n                                    |\n                                    \\-------- 24D\n</code></pre> Note that tips for 24A, 24B, and 24C have been added to distinguish between the ancestral taxon and observed taxa.</p> <p>We can use this tree to construct a <code>PhylogeneticTaxonomyScheme</code> which we can then use in aggregation.</p> <pre><code>import datetime\n\nscheme = cladecombiner.PhylogeneticTaxonomyScheme(tree)\n\nagg = cladecombiner.AsOfAggregator(scheme, ns, datetime.date(2024, 6, 1))\n\nres = agg.aggregate(taxa)\n</code></pre> <p>This yields:</p> <pre><code>Taxon(24A, tip=True) : Taxon(24A, tip=False)\nTaxon(24B, tip=True) : Taxon(24B, tip=False)\nTaxon(24C, tip=True) : Taxon(24B, tip=False)\nTaxon(24D, tip=True) : Taxon(21L, tip=False)\nTaxon(24E, tip=True) : Taxon(24B, tip=False)\nTaxon(24F, tip=True) : Taxon(24A, tip=False)\nTaxon(24G, tip=True) : Taxon(24B, tip=False)\nTaxon(24I, tip=True) : Taxon(24A, tip=False)\nTaxon(24H, tip=True) : Taxon(24A, tip=False)\n</code></pre>"}]}